// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.20.3
// source: gql_types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "gql";

/** GQL type enumeration covering all types from ISO/IEC 39075. */
export enum GqlType {
  TYPE_UNKNOWN = 0,
  TYPE_NULL = 1,
  TYPE_BOOLEAN = 2,
  /** TYPE_INT8 - Signed integers */
  TYPE_INT8 = 10,
  TYPE_INT16 = 11,
  TYPE_INT32 = 12,
  TYPE_INT64 = 13,
  TYPE_INT128 = 14,
  TYPE_INT256 = 15,
  /** TYPE_UINT8 - Unsigned integers */
  TYPE_UINT8 = 20,
  TYPE_UINT16 = 21,
  TYPE_UINT32 = 22,
  TYPE_UINT64 = 23,
  TYPE_UINT128 = 24,
  TYPE_UINT256 = 25,
  /** TYPE_FLOAT16 - Floating point */
  TYPE_FLOAT16 = 30,
  TYPE_FLOAT32 = 31,
  TYPE_FLOAT64 = 32,
  TYPE_FLOAT128 = 33,
  TYPE_FLOAT256 = 34,
  /** TYPE_DECIMAL - Decimal */
  TYPE_DECIMAL = 40,
  /** TYPE_STRING - String / bytes */
  TYPE_STRING = 50,
  TYPE_BYTES = 60,
  /** TYPE_DATE - Temporal */
  TYPE_DATE = 70,
  TYPE_LOCAL_TIME = 71,
  TYPE_ZONED_TIME = 72,
  TYPE_LOCAL_DATETIME = 73,
  TYPE_ZONED_DATETIME = 74,
  TYPE_DURATION = 75,
  /** TYPE_LIST - Constructed */
  TYPE_LIST = 80,
  TYPE_RECORD = 81,
  TYPE_PATH = 82,
  /** TYPE_NODE - Graph elements */
  TYPE_NODE = 90,
  TYPE_EDGE = 91,
  /** TYPE_ANY - Dynamic */
  TYPE_ANY = 110,
  TYPE_PROPERTY_VALUE = 111,
  UNRECOGNIZED = -1,
}

export function gqlTypeFromJSON(object: any): GqlType {
  switch (object) {
    case 0:
    case "TYPE_UNKNOWN":
      return GqlType.TYPE_UNKNOWN;
    case 1:
    case "TYPE_NULL":
      return GqlType.TYPE_NULL;
    case 2:
    case "TYPE_BOOLEAN":
      return GqlType.TYPE_BOOLEAN;
    case 10:
    case "TYPE_INT8":
      return GqlType.TYPE_INT8;
    case 11:
    case "TYPE_INT16":
      return GqlType.TYPE_INT16;
    case 12:
    case "TYPE_INT32":
      return GqlType.TYPE_INT32;
    case 13:
    case "TYPE_INT64":
      return GqlType.TYPE_INT64;
    case 14:
    case "TYPE_INT128":
      return GqlType.TYPE_INT128;
    case 15:
    case "TYPE_INT256":
      return GqlType.TYPE_INT256;
    case 20:
    case "TYPE_UINT8":
      return GqlType.TYPE_UINT8;
    case 21:
    case "TYPE_UINT16":
      return GqlType.TYPE_UINT16;
    case 22:
    case "TYPE_UINT32":
      return GqlType.TYPE_UINT32;
    case 23:
    case "TYPE_UINT64":
      return GqlType.TYPE_UINT64;
    case 24:
    case "TYPE_UINT128":
      return GqlType.TYPE_UINT128;
    case 25:
    case "TYPE_UINT256":
      return GqlType.TYPE_UINT256;
    case 30:
    case "TYPE_FLOAT16":
      return GqlType.TYPE_FLOAT16;
    case 31:
    case "TYPE_FLOAT32":
      return GqlType.TYPE_FLOAT32;
    case 32:
    case "TYPE_FLOAT64":
      return GqlType.TYPE_FLOAT64;
    case 33:
    case "TYPE_FLOAT128":
      return GqlType.TYPE_FLOAT128;
    case 34:
    case "TYPE_FLOAT256":
      return GqlType.TYPE_FLOAT256;
    case 40:
    case "TYPE_DECIMAL":
      return GqlType.TYPE_DECIMAL;
    case 50:
    case "TYPE_STRING":
      return GqlType.TYPE_STRING;
    case 60:
    case "TYPE_BYTES":
      return GqlType.TYPE_BYTES;
    case 70:
    case "TYPE_DATE":
      return GqlType.TYPE_DATE;
    case 71:
    case "TYPE_LOCAL_TIME":
      return GqlType.TYPE_LOCAL_TIME;
    case 72:
    case "TYPE_ZONED_TIME":
      return GqlType.TYPE_ZONED_TIME;
    case 73:
    case "TYPE_LOCAL_DATETIME":
      return GqlType.TYPE_LOCAL_DATETIME;
    case 74:
    case "TYPE_ZONED_DATETIME":
      return GqlType.TYPE_ZONED_DATETIME;
    case 75:
    case "TYPE_DURATION":
      return GqlType.TYPE_DURATION;
    case 80:
    case "TYPE_LIST":
      return GqlType.TYPE_LIST;
    case 81:
    case "TYPE_RECORD":
      return GqlType.TYPE_RECORD;
    case 82:
    case "TYPE_PATH":
      return GqlType.TYPE_PATH;
    case 90:
    case "TYPE_NODE":
      return GqlType.TYPE_NODE;
    case 91:
    case "TYPE_EDGE":
      return GqlType.TYPE_EDGE;
    case 110:
    case "TYPE_ANY":
      return GqlType.TYPE_ANY;
    case 111:
    case "TYPE_PROPERTY_VALUE":
      return GqlType.TYPE_PROPERTY_VALUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GqlType.UNRECOGNIZED;
  }
}

export function gqlTypeToJSON(object: GqlType): string {
  switch (object) {
    case GqlType.TYPE_UNKNOWN:
      return "TYPE_UNKNOWN";
    case GqlType.TYPE_NULL:
      return "TYPE_NULL";
    case GqlType.TYPE_BOOLEAN:
      return "TYPE_BOOLEAN";
    case GqlType.TYPE_INT8:
      return "TYPE_INT8";
    case GqlType.TYPE_INT16:
      return "TYPE_INT16";
    case GqlType.TYPE_INT32:
      return "TYPE_INT32";
    case GqlType.TYPE_INT64:
      return "TYPE_INT64";
    case GqlType.TYPE_INT128:
      return "TYPE_INT128";
    case GqlType.TYPE_INT256:
      return "TYPE_INT256";
    case GqlType.TYPE_UINT8:
      return "TYPE_UINT8";
    case GqlType.TYPE_UINT16:
      return "TYPE_UINT16";
    case GqlType.TYPE_UINT32:
      return "TYPE_UINT32";
    case GqlType.TYPE_UINT64:
      return "TYPE_UINT64";
    case GqlType.TYPE_UINT128:
      return "TYPE_UINT128";
    case GqlType.TYPE_UINT256:
      return "TYPE_UINT256";
    case GqlType.TYPE_FLOAT16:
      return "TYPE_FLOAT16";
    case GqlType.TYPE_FLOAT32:
      return "TYPE_FLOAT32";
    case GqlType.TYPE_FLOAT64:
      return "TYPE_FLOAT64";
    case GqlType.TYPE_FLOAT128:
      return "TYPE_FLOAT128";
    case GqlType.TYPE_FLOAT256:
      return "TYPE_FLOAT256";
    case GqlType.TYPE_DECIMAL:
      return "TYPE_DECIMAL";
    case GqlType.TYPE_STRING:
      return "TYPE_STRING";
    case GqlType.TYPE_BYTES:
      return "TYPE_BYTES";
    case GqlType.TYPE_DATE:
      return "TYPE_DATE";
    case GqlType.TYPE_LOCAL_TIME:
      return "TYPE_LOCAL_TIME";
    case GqlType.TYPE_ZONED_TIME:
      return "TYPE_ZONED_TIME";
    case GqlType.TYPE_LOCAL_DATETIME:
      return "TYPE_LOCAL_DATETIME";
    case GqlType.TYPE_ZONED_DATETIME:
      return "TYPE_ZONED_DATETIME";
    case GqlType.TYPE_DURATION:
      return "TYPE_DURATION";
    case GqlType.TYPE_LIST:
      return "TYPE_LIST";
    case GqlType.TYPE_RECORD:
      return "TYPE_RECORD";
    case GqlType.TYPE_PATH:
      return "TYPE_PATH";
    case GqlType.TYPE_NODE:
      return "TYPE_NODE";
    case GqlType.TYPE_EDGE:
      return "TYPE_EDGE";
    case GqlType.TYPE_ANY:
      return "TYPE_ANY";
    case GqlType.TYPE_PROPERTY_VALUE:
      return "TYPE_PROPERTY_VALUE";
    case GqlType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Discriminated union of all GQL value types. */
export interface Value {
  /** Null */
  nullValue?:
    | NullValue
    | undefined;
  /** Boolean */
  booleanValue?:
    | boolean
    | undefined;
  /** Signed integer (INT8 through INT64) */
  integerValue?:
    | bigint
    | undefined;
  /** Unsigned integer (UINT8 through UINT64) */
  unsignedIntegerValue?:
    | bigint
    | undefined;
  /** Extended-precision integer (INT128/256, UINT128/256) */
  bigIntegerValue?:
    | BigInteger
    | undefined;
  /** Floating point (FLOAT32/64) */
  floatValue?:
    | number
    | undefined;
  /** Extended-precision float (FLOAT128/256) */
  bigFloatValue?:
    | BigFloat
    | undefined;
  /** Decimal with arbitrary precision */
  decimalValue?:
    | Decimal
    | undefined;
  /** String */
  stringValue?:
    | string
    | undefined;
  /** Byte string */
  bytesValue?:
    | Uint8Array
    | undefined;
  /** Temporal types */
  dateValue?: DateMessage | undefined;
  localTimeValue?: LocalTime | undefined;
  zonedTimeValue?: ZonedTime | undefined;
  localDatetimeValue?: LocalDateTime | undefined;
  zonedDatetimeValue?: ZonedDateTime | undefined;
  durationValue?:
    | Duration
    | undefined;
  /** Constructed types */
  listValue?: GqlList | undefined;
  recordValue?:
    | Record
    | undefined;
  /** Graph element types */
  nodeValue?: Node | undefined;
  edgeValue?: Edge | undefined;
  pathValue?: Path | undefined;
}

/** Explicit null marker (GQL NULL). */
export interface NullValue {
}

/** Extended-precision integer (INT128/256, UINT128/256). */
export interface BigInteger {
  /** Big-endian two's complement */
  value: Uint8Array;
  isSigned: boolean;
}

/** Extended-precision float (FLOAT128/256). */
export interface BigFloat {
  /** IEEE 754 encoding */
  value: Uint8Array;
  /** 128 or 256 */
  width: number;
}

/** Arbitrary-precision decimal. */
export interface Decimal {
  /** Big-endian two's complement of unscaled value */
  unscaled: Uint8Array;
  /** Number of digits after the decimal point */
  scale: number;
}

/** Calendar date. */
export interface DateMessage {
  year: number;
  /** 1-12 */
  month: number;
  /** 1-31 */
  day: number;
}

/** Time without timezone. */
export interface LocalTime {
  /** 0-23 */
  hour: number;
  /** 0-59 */
  minute: number;
  /** 0-59 */
  second: number;
  /** 0-999999999 */
  nanosecond: number;
}

/** Time with UTC offset. */
export interface ZonedTime {
  time:
    | LocalTime
    | undefined;
  /** UTC offset in minutes */
  offsetMinutes: number;
}

/** Date and time without timezone. */
export interface LocalDateTime {
  date: DateMessage | undefined;
  time: LocalTime | undefined;
}

/** Date and time with UTC offset. */
export interface ZonedDateTime {
  date: DateMessage | undefined;
  time: LocalTime | undefined;
  offsetMinutes: number;
}

/** Temporal duration with two components per ISO/IEC 39075. */
export interface Duration {
  /** Year-to-month component */
  months: bigint;
  /** Day-to-second component */
  nanoseconds: bigint;
}

/** Property graph node. */
export interface Node {
  /** Opaque element identifier */
  id: Uint8Array;
  /** Label set (unordered) */
  labels: string[];
  /** Property map */
  properties: { [key: string]: Value };
}

export interface Node_PropertiesEntry {
  key: string;
  value: Value | undefined;
}

/** Property graph edge (directed or undirected). */
export interface Edge {
  /** Opaque element identifier */
  id: Uint8Array;
  /** Label set */
  labels: string[];
  /** Source node (directed) or endpoint A */
  sourceNodeId: Uint8Array;
  /** Target node (directed) or endpoint B */
  targetNodeId: Uint8Array;
  /** true = undirected edge */
  undirected: boolean;
  /** Property map */
  properties: { [key: string]: Value };
}

export interface Edge_PropertiesEntry {
  key: string;
  value: Value | undefined;
}

/**
 * Alternating sequence of nodes and edges.
 * nodes[i] and nodes[i+1] are connected by edges[i].
 */
export interface Path {
  nodes: Node[];
  edges: Edge[];
}

/** Ordered list of values. */
export interface GqlList {
  elements: Value[];
}

/** Named collection of fields (open or closed record). */
export interface Record {
  fields: Field[];
}

/** Single field within a record. */
export interface Field {
  name: string;
  value: Value | undefined;
}

export interface TypeDescriptor {
  type: GqlType;
  nullable: boolean;
  /** For LIST: element type */
  elementType:
    | TypeDescriptor
    | undefined;
  /** For RECORD: field types */
  fields: FieldDescriptor[];
}

export interface FieldDescriptor {
  name: string;
  type: TypeDescriptor | undefined;
}

/** Status code from a GQL operation. */
export interface GqlStatus {
  /** 5-char GQLSTATUS code */
  code: string;
  /** Human-readable description */
  message: string;
  /** Optional diagnostic context */
  diagnostic:
    | DiagnosticRecord
    | undefined;
  /** Optional chained cause */
  cause: GqlStatus | undefined;
}

/** Diagnostic context for error reporting. */
export interface DiagnosticRecord {
  /** e.g. "MATCH STATEMENT" */
  operation: string;
  /** e.g. 600 */
  operationCode: number;
  /** Schema context */
  currentSchema: string;
}

/** Credentials provided at handshake. */
export interface AuthCredentials {
  bearerToken?: string | undefined;
  basic?: BasicAuth | undefined;
}

/** Username/password credentials. */
export interface BasicAuth {
  username: string;
  password: string;
}

function createBaseValue(): Value {
  return {
    nullValue: undefined,
    booleanValue: undefined,
    integerValue: undefined,
    unsignedIntegerValue: undefined,
    bigIntegerValue: undefined,
    floatValue: undefined,
    bigFloatValue: undefined,
    decimalValue: undefined,
    stringValue: undefined,
    bytesValue: undefined,
    dateValue: undefined,
    localTimeValue: undefined,
    zonedTimeValue: undefined,
    localDatetimeValue: undefined,
    zonedDatetimeValue: undefined,
    durationValue: undefined,
    listValue: undefined,
    recordValue: undefined,
    nodeValue: undefined,
    edgeValue: undefined,
    pathValue: undefined,
  };
}

export const Value: MessageFns<Value> = {
  encode(message: Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nullValue !== undefined) {
      NullValue.encode(message.nullValue, writer.uint32(10).fork()).join();
    }
    if (message.booleanValue !== undefined) {
      writer.uint32(16).bool(message.booleanValue);
    }
    if (message.integerValue !== undefined) {
      if (BigInt.asIntN(64, message.integerValue) !== message.integerValue) {
        throw new globalThis.Error("value provided for field message.integerValue of type int64 too large");
      }
      writer.uint32(24).int64(message.integerValue);
    }
    if (message.unsignedIntegerValue !== undefined) {
      if (BigInt.asUintN(64, message.unsignedIntegerValue) !== message.unsignedIntegerValue) {
        throw new globalThis.Error("value provided for field message.unsignedIntegerValue of type uint64 too large");
      }
      writer.uint32(32).uint64(message.unsignedIntegerValue);
    }
    if (message.bigIntegerValue !== undefined) {
      BigInteger.encode(message.bigIntegerValue, writer.uint32(42).fork()).join();
    }
    if (message.floatValue !== undefined) {
      writer.uint32(49).double(message.floatValue);
    }
    if (message.bigFloatValue !== undefined) {
      BigFloat.encode(message.bigFloatValue, writer.uint32(58).fork()).join();
    }
    if (message.decimalValue !== undefined) {
      Decimal.encode(message.decimalValue, writer.uint32(66).fork()).join();
    }
    if (message.stringValue !== undefined) {
      writer.uint32(74).string(message.stringValue);
    }
    if (message.bytesValue !== undefined) {
      writer.uint32(82).bytes(message.bytesValue);
    }
    if (message.dateValue !== undefined) {
      DateMessage.encode(message.dateValue, writer.uint32(90).fork()).join();
    }
    if (message.localTimeValue !== undefined) {
      LocalTime.encode(message.localTimeValue, writer.uint32(98).fork()).join();
    }
    if (message.zonedTimeValue !== undefined) {
      ZonedTime.encode(message.zonedTimeValue, writer.uint32(106).fork()).join();
    }
    if (message.localDatetimeValue !== undefined) {
      LocalDateTime.encode(message.localDatetimeValue, writer.uint32(114).fork()).join();
    }
    if (message.zonedDatetimeValue !== undefined) {
      ZonedDateTime.encode(message.zonedDatetimeValue, writer.uint32(122).fork()).join();
    }
    if (message.durationValue !== undefined) {
      Duration.encode(message.durationValue, writer.uint32(130).fork()).join();
    }
    if (message.listValue !== undefined) {
      GqlList.encode(message.listValue, writer.uint32(138).fork()).join();
    }
    if (message.recordValue !== undefined) {
      Record.encode(message.recordValue, writer.uint32(146).fork()).join();
    }
    if (message.nodeValue !== undefined) {
      Node.encode(message.nodeValue, writer.uint32(154).fork()).join();
    }
    if (message.edgeValue !== undefined) {
      Edge.encode(message.edgeValue, writer.uint32(162).fork()).join();
    }
    if (message.pathValue !== undefined) {
      Path.encode(message.pathValue, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Value {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nullValue = NullValue.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.booleanValue = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.integerValue = reader.int64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.unsignedIntegerValue = reader.uint64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bigIntegerValue = BigInteger.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.floatValue = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.bigFloatValue = BigFloat.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.decimalValue = Decimal.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.bytesValue = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.dateValue = DateMessage.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.localTimeValue = LocalTime.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.zonedTimeValue = ZonedTime.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.localDatetimeValue = LocalDateTime.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.zonedDatetimeValue = ZonedDateTime.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.durationValue = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.listValue = GqlList.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.recordValue = Record.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.nodeValue = Node.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.edgeValue = Edge.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.pathValue = Path.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Value {
    return {
      nullValue: isSet(object.nullValue)
        ? NullValue.fromJSON(object.nullValue)
        : isSet(object.null_value)
        ? NullValue.fromJSON(object.null_value)
        : undefined,
      booleanValue: isSet(object.booleanValue)
        ? globalThis.Boolean(object.booleanValue)
        : isSet(object.boolean_value)
        ? globalThis.Boolean(object.boolean_value)
        : undefined,
      integerValue: isSet(object.integerValue)
        ? BigInt(object.integerValue)
        : isSet(object.integer_value)
        ? BigInt(object.integer_value)
        : undefined,
      unsignedIntegerValue: isSet(object.unsignedIntegerValue)
        ? BigInt(object.unsignedIntegerValue)
        : isSet(object.unsigned_integer_value)
        ? BigInt(object.unsigned_integer_value)
        : undefined,
      bigIntegerValue: isSet(object.bigIntegerValue)
        ? BigInteger.fromJSON(object.bigIntegerValue)
        : isSet(object.big_integer_value)
        ? BigInteger.fromJSON(object.big_integer_value)
        : undefined,
      floatValue: isSet(object.floatValue)
        ? globalThis.Number(object.floatValue)
        : isSet(object.float_value)
        ? globalThis.Number(object.float_value)
        : undefined,
      bigFloatValue: isSet(object.bigFloatValue)
        ? BigFloat.fromJSON(object.bigFloatValue)
        : isSet(object.big_float_value)
        ? BigFloat.fromJSON(object.big_float_value)
        : undefined,
      decimalValue: isSet(object.decimalValue)
        ? Decimal.fromJSON(object.decimalValue)
        : isSet(object.decimal_value)
        ? Decimal.fromJSON(object.decimal_value)
        : undefined,
      stringValue: isSet(object.stringValue)
        ? globalThis.String(object.stringValue)
        : isSet(object.string_value)
        ? globalThis.String(object.string_value)
        : undefined,
      bytesValue: isSet(object.bytesValue)
        ? bytesFromBase64(object.bytesValue)
        : isSet(object.bytes_value)
        ? bytesFromBase64(object.bytes_value)
        : undefined,
      dateValue: isSet(object.dateValue)
        ? DateMessage.fromJSON(object.dateValue)
        : isSet(object.date_value)
        ? DateMessage.fromJSON(object.date_value)
        : undefined,
      localTimeValue: isSet(object.localTimeValue)
        ? LocalTime.fromJSON(object.localTimeValue)
        : isSet(object.local_time_value)
        ? LocalTime.fromJSON(object.local_time_value)
        : undefined,
      zonedTimeValue: isSet(object.zonedTimeValue)
        ? ZonedTime.fromJSON(object.zonedTimeValue)
        : isSet(object.zoned_time_value)
        ? ZonedTime.fromJSON(object.zoned_time_value)
        : undefined,
      localDatetimeValue: isSet(object.localDatetimeValue)
        ? LocalDateTime.fromJSON(object.localDatetimeValue)
        : isSet(object.local_datetime_value)
        ? LocalDateTime.fromJSON(object.local_datetime_value)
        : undefined,
      zonedDatetimeValue: isSet(object.zonedDatetimeValue)
        ? ZonedDateTime.fromJSON(object.zonedDatetimeValue)
        : isSet(object.zoned_datetime_value)
        ? ZonedDateTime.fromJSON(object.zoned_datetime_value)
        : undefined,
      durationValue: isSet(object.durationValue)
        ? Duration.fromJSON(object.durationValue)
        : isSet(object.duration_value)
        ? Duration.fromJSON(object.duration_value)
        : undefined,
      listValue: isSet(object.listValue)
        ? GqlList.fromJSON(object.listValue)
        : isSet(object.list_value)
        ? GqlList.fromJSON(object.list_value)
        : undefined,
      recordValue: isSet(object.recordValue)
        ? Record.fromJSON(object.recordValue)
        : isSet(object.record_value)
        ? Record.fromJSON(object.record_value)
        : undefined,
      nodeValue: isSet(object.nodeValue)
        ? Node.fromJSON(object.nodeValue)
        : isSet(object.node_value)
        ? Node.fromJSON(object.node_value)
        : undefined,
      edgeValue: isSet(object.edgeValue)
        ? Edge.fromJSON(object.edgeValue)
        : isSet(object.edge_value)
        ? Edge.fromJSON(object.edge_value)
        : undefined,
      pathValue: isSet(object.pathValue)
        ? Path.fromJSON(object.pathValue)
        : isSet(object.path_value)
        ? Path.fromJSON(object.path_value)
        : undefined,
    };
  },

  toJSON(message: Value): unknown {
    const obj: any = {};
    if (message.nullValue !== undefined) {
      obj.nullValue = NullValue.toJSON(message.nullValue);
    }
    if (message.booleanValue !== undefined) {
      obj.booleanValue = message.booleanValue;
    }
    if (message.integerValue !== undefined) {
      obj.integerValue = message.integerValue.toString();
    }
    if (message.unsignedIntegerValue !== undefined) {
      obj.unsignedIntegerValue = message.unsignedIntegerValue.toString();
    }
    if (message.bigIntegerValue !== undefined) {
      obj.bigIntegerValue = BigInteger.toJSON(message.bigIntegerValue);
    }
    if (message.floatValue !== undefined) {
      obj.floatValue = message.floatValue;
    }
    if (message.bigFloatValue !== undefined) {
      obj.bigFloatValue = BigFloat.toJSON(message.bigFloatValue);
    }
    if (message.decimalValue !== undefined) {
      obj.decimalValue = Decimal.toJSON(message.decimalValue);
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.bytesValue !== undefined) {
      obj.bytesValue = base64FromBytes(message.bytesValue);
    }
    if (message.dateValue !== undefined) {
      obj.dateValue = DateMessage.toJSON(message.dateValue);
    }
    if (message.localTimeValue !== undefined) {
      obj.localTimeValue = LocalTime.toJSON(message.localTimeValue);
    }
    if (message.zonedTimeValue !== undefined) {
      obj.zonedTimeValue = ZonedTime.toJSON(message.zonedTimeValue);
    }
    if (message.localDatetimeValue !== undefined) {
      obj.localDatetimeValue = LocalDateTime.toJSON(message.localDatetimeValue);
    }
    if (message.zonedDatetimeValue !== undefined) {
      obj.zonedDatetimeValue = ZonedDateTime.toJSON(message.zonedDatetimeValue);
    }
    if (message.durationValue !== undefined) {
      obj.durationValue = Duration.toJSON(message.durationValue);
    }
    if (message.listValue !== undefined) {
      obj.listValue = GqlList.toJSON(message.listValue);
    }
    if (message.recordValue !== undefined) {
      obj.recordValue = Record.toJSON(message.recordValue);
    }
    if (message.nodeValue !== undefined) {
      obj.nodeValue = Node.toJSON(message.nodeValue);
    }
    if (message.edgeValue !== undefined) {
      obj.edgeValue = Edge.toJSON(message.edgeValue);
    }
    if (message.pathValue !== undefined) {
      obj.pathValue = Path.toJSON(message.pathValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Value>, I>>(base?: I): Value {
    return Value.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Value>, I>>(object: I): Value {
    const message = createBaseValue();
    message.nullValue = (object.nullValue !== undefined && object.nullValue !== null)
      ? NullValue.fromPartial(object.nullValue)
      : undefined;
    message.booleanValue = object.booleanValue ?? undefined;
    message.integerValue = object.integerValue ?? undefined;
    message.unsignedIntegerValue = object.unsignedIntegerValue ?? undefined;
    message.bigIntegerValue = (object.bigIntegerValue !== undefined && object.bigIntegerValue !== null)
      ? BigInteger.fromPartial(object.bigIntegerValue)
      : undefined;
    message.floatValue = object.floatValue ?? undefined;
    message.bigFloatValue = (object.bigFloatValue !== undefined && object.bigFloatValue !== null)
      ? BigFloat.fromPartial(object.bigFloatValue)
      : undefined;
    message.decimalValue = (object.decimalValue !== undefined && object.decimalValue !== null)
      ? Decimal.fromPartial(object.decimalValue)
      : undefined;
    message.stringValue = object.stringValue ?? undefined;
    message.bytesValue = object.bytesValue ?? undefined;
    message.dateValue = (object.dateValue !== undefined && object.dateValue !== null)
      ? DateMessage.fromPartial(object.dateValue)
      : undefined;
    message.localTimeValue = (object.localTimeValue !== undefined && object.localTimeValue !== null)
      ? LocalTime.fromPartial(object.localTimeValue)
      : undefined;
    message.zonedTimeValue = (object.zonedTimeValue !== undefined && object.zonedTimeValue !== null)
      ? ZonedTime.fromPartial(object.zonedTimeValue)
      : undefined;
    message.localDatetimeValue = (object.localDatetimeValue !== undefined && object.localDatetimeValue !== null)
      ? LocalDateTime.fromPartial(object.localDatetimeValue)
      : undefined;
    message.zonedDatetimeValue = (object.zonedDatetimeValue !== undefined && object.zonedDatetimeValue !== null)
      ? ZonedDateTime.fromPartial(object.zonedDatetimeValue)
      : undefined;
    message.durationValue = (object.durationValue !== undefined && object.durationValue !== null)
      ? Duration.fromPartial(object.durationValue)
      : undefined;
    message.listValue = (object.listValue !== undefined && object.listValue !== null)
      ? GqlList.fromPartial(object.listValue)
      : undefined;
    message.recordValue = (object.recordValue !== undefined && object.recordValue !== null)
      ? Record.fromPartial(object.recordValue)
      : undefined;
    message.nodeValue = (object.nodeValue !== undefined && object.nodeValue !== null)
      ? Node.fromPartial(object.nodeValue)
      : undefined;
    message.edgeValue = (object.edgeValue !== undefined && object.edgeValue !== null)
      ? Edge.fromPartial(object.edgeValue)
      : undefined;
    message.pathValue = (object.pathValue !== undefined && object.pathValue !== null)
      ? Path.fromPartial(object.pathValue)
      : undefined;
    return message;
  },
};

function createBaseNullValue(): NullValue {
  return {};
}

export const NullValue: MessageFns<NullValue> = {
  encode(_: NullValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NullValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNullValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NullValue {
    return {};
  },

  toJSON(_: NullValue): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NullValue>, I>>(base?: I): NullValue {
    return NullValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NullValue>, I>>(_: I): NullValue {
    const message = createBaseNullValue();
    return message;
  },
};

function createBaseBigInteger(): BigInteger {
  return { value: new Uint8Array(0), isSigned: false };
}

export const BigInteger: MessageFns<BigInteger> = {
  encode(message: BigInteger, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value.length !== 0) {
      writer.uint32(10).bytes(message.value);
    }
    if (message.isSigned !== false) {
      writer.uint32(16).bool(message.isSigned);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BigInteger {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBigInteger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSigned = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BigInteger {
    return {
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
      isSigned: isSet(object.isSigned)
        ? globalThis.Boolean(object.isSigned)
        : isSet(object.is_signed)
        ? globalThis.Boolean(object.is_signed)
        : false,
    };
  },

  toJSON(message: BigInteger): unknown {
    const obj: any = {};
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.isSigned !== false) {
      obj.isSigned = message.isSigned;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BigInteger>, I>>(base?: I): BigInteger {
    return BigInteger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BigInteger>, I>>(object: I): BigInteger {
    const message = createBaseBigInteger();
    message.value = object.value ?? new Uint8Array(0);
    message.isSigned = object.isSigned ?? false;
    return message;
  },
};

function createBaseBigFloat(): BigFloat {
  return { value: new Uint8Array(0), width: 0 };
}

export const BigFloat: MessageFns<BigFloat> = {
  encode(message: BigFloat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value.length !== 0) {
      writer.uint32(10).bytes(message.value);
    }
    if (message.width !== 0) {
      writer.uint32(16).uint32(message.width);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BigFloat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBigFloat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.width = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BigFloat {
    return {
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
    };
  },

  toJSON(message: BigFloat): unknown {
    const obj: any = {};
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BigFloat>, I>>(base?: I): BigFloat {
    return BigFloat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BigFloat>, I>>(object: I): BigFloat {
    const message = createBaseBigFloat();
    message.value = object.value ?? new Uint8Array(0);
    message.width = object.width ?? 0;
    return message;
  },
};

function createBaseDecimal(): Decimal {
  return { unscaled: new Uint8Array(0), scale: 0 };
}

export const Decimal: MessageFns<Decimal> = {
  encode(message: Decimal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unscaled.length !== 0) {
      writer.uint32(10).bytes(message.unscaled);
    }
    if (message.scale !== 0) {
      writer.uint32(16).int32(message.scale);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Decimal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecimal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unscaled = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.scale = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Decimal {
    return {
      unscaled: isSet(object.unscaled) ? bytesFromBase64(object.unscaled) : new Uint8Array(0),
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
    };
  },

  toJSON(message: Decimal): unknown {
    const obj: any = {};
    if (message.unscaled.length !== 0) {
      obj.unscaled = base64FromBytes(message.unscaled);
    }
    if (message.scale !== 0) {
      obj.scale = Math.round(message.scale);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Decimal>, I>>(base?: I): Decimal {
    return Decimal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Decimal>, I>>(object: I): Decimal {
    const message = createBaseDecimal();
    message.unscaled = object.unscaled ?? new Uint8Array(0);
    message.scale = object.scale ?? 0;
    return message;
  },
};

function createBaseDateMessage(): DateMessage {
  return { year: 0, month: 0, day: 0 };
}

export const DateMessage: MessageFns<DateMessage> = {
  encode(message: DateMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.year !== 0) {
      writer.uint32(8).int32(message.year);
    }
    if (message.month !== 0) {
      writer.uint32(16).uint32(message.month);
    }
    if (message.day !== 0) {
      writer.uint32(24).uint32(message.day);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DateMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.month = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.day = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DateMessage {
    return {
      year: isSet(object.year) ? globalThis.Number(object.year) : 0,
      month: isSet(object.month) ? globalThis.Number(object.month) : 0,
      day: isSet(object.day) ? globalThis.Number(object.day) : 0,
    };
  },

  toJSON(message: DateMessage): unknown {
    const obj: any = {};
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    if (message.month !== 0) {
      obj.month = Math.round(message.month);
    }
    if (message.day !== 0) {
      obj.day = Math.round(message.day);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DateMessage>, I>>(base?: I): DateMessage {
    return DateMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DateMessage>, I>>(object: I): DateMessage {
    const message = createBaseDateMessage();
    message.year = object.year ?? 0;
    message.month = object.month ?? 0;
    message.day = object.day ?? 0;
    return message;
  },
};

function createBaseLocalTime(): LocalTime {
  return { hour: 0, minute: 0, second: 0, nanosecond: 0 };
}

export const LocalTime: MessageFns<LocalTime> = {
  encode(message: LocalTime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hour !== 0) {
      writer.uint32(8).uint32(message.hour);
    }
    if (message.minute !== 0) {
      writer.uint32(16).uint32(message.minute);
    }
    if (message.second !== 0) {
      writer.uint32(24).uint32(message.second);
    }
    if (message.nanosecond !== 0) {
      writer.uint32(32).uint32(message.nanosecond);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hour = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.minute = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.second = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.nanosecond = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalTime {
    return {
      hour: isSet(object.hour) ? globalThis.Number(object.hour) : 0,
      minute: isSet(object.minute) ? globalThis.Number(object.minute) : 0,
      second: isSet(object.second) ? globalThis.Number(object.second) : 0,
      nanosecond: isSet(object.nanosecond) ? globalThis.Number(object.nanosecond) : 0,
    };
  },

  toJSON(message: LocalTime): unknown {
    const obj: any = {};
    if (message.hour !== 0) {
      obj.hour = Math.round(message.hour);
    }
    if (message.minute !== 0) {
      obj.minute = Math.round(message.minute);
    }
    if (message.second !== 0) {
      obj.second = Math.round(message.second);
    }
    if (message.nanosecond !== 0) {
      obj.nanosecond = Math.round(message.nanosecond);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalTime>, I>>(base?: I): LocalTime {
    return LocalTime.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalTime>, I>>(object: I): LocalTime {
    const message = createBaseLocalTime();
    message.hour = object.hour ?? 0;
    message.minute = object.minute ?? 0;
    message.second = object.second ?? 0;
    message.nanosecond = object.nanosecond ?? 0;
    return message;
  },
};

function createBaseZonedTime(): ZonedTime {
  return { time: undefined, offsetMinutes: 0 };
}

export const ZonedTime: MessageFns<ZonedTime> = {
  encode(message: ZonedTime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time !== undefined) {
      LocalTime.encode(message.time, writer.uint32(10).fork()).join();
    }
    if (message.offsetMinutes !== 0) {
      writer.uint32(16).int32(message.offsetMinutes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ZonedTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZonedTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.time = LocalTime.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offsetMinutes = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ZonedTime {
    return {
      time: isSet(object.time) ? LocalTime.fromJSON(object.time) : undefined,
      offsetMinutes: isSet(object.offsetMinutes)
        ? globalThis.Number(object.offsetMinutes)
        : isSet(object.offset_minutes)
        ? globalThis.Number(object.offset_minutes)
        : 0,
    };
  },

  toJSON(message: ZonedTime): unknown {
    const obj: any = {};
    if (message.time !== undefined) {
      obj.time = LocalTime.toJSON(message.time);
    }
    if (message.offsetMinutes !== 0) {
      obj.offsetMinutes = Math.round(message.offsetMinutes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ZonedTime>, I>>(base?: I): ZonedTime {
    return ZonedTime.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ZonedTime>, I>>(object: I): ZonedTime {
    const message = createBaseZonedTime();
    message.time = (object.time !== undefined && object.time !== null) ? LocalTime.fromPartial(object.time) : undefined;
    message.offsetMinutes = object.offsetMinutes ?? 0;
    return message;
  },
};

function createBaseLocalDateTime(): LocalDateTime {
  return { date: undefined, time: undefined };
}

export const LocalDateTime: MessageFns<LocalDateTime> = {
  encode(message: LocalDateTime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== undefined) {
      DateMessage.encode(message.date, writer.uint32(10).fork()).join();
    }
    if (message.time !== undefined) {
      LocalTime.encode(message.time, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalDateTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalDateTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.date = DateMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.time = LocalTime.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalDateTime {
    return {
      date: isSet(object.date) ? DateMessage.fromJSON(object.date) : undefined,
      time: isSet(object.time) ? LocalTime.fromJSON(object.time) : undefined,
    };
  },

  toJSON(message: LocalDateTime): unknown {
    const obj: any = {};
    if (message.date !== undefined) {
      obj.date = DateMessage.toJSON(message.date);
    }
    if (message.time !== undefined) {
      obj.time = LocalTime.toJSON(message.time);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalDateTime>, I>>(base?: I): LocalDateTime {
    return LocalDateTime.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalDateTime>, I>>(object: I): LocalDateTime {
    const message = createBaseLocalDateTime();
    message.date = (object.date !== undefined && object.date !== null)
      ? DateMessage.fromPartial(object.date)
      : undefined;
    message.time = (object.time !== undefined && object.time !== null) ? LocalTime.fromPartial(object.time) : undefined;
    return message;
  },
};

function createBaseZonedDateTime(): ZonedDateTime {
  return { date: undefined, time: undefined, offsetMinutes: 0 };
}

export const ZonedDateTime: MessageFns<ZonedDateTime> = {
  encode(message: ZonedDateTime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== undefined) {
      DateMessage.encode(message.date, writer.uint32(10).fork()).join();
    }
    if (message.time !== undefined) {
      LocalTime.encode(message.time, writer.uint32(18).fork()).join();
    }
    if (message.offsetMinutes !== 0) {
      writer.uint32(24).int32(message.offsetMinutes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ZonedDateTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZonedDateTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.date = DateMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.time = LocalTime.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offsetMinutes = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ZonedDateTime {
    return {
      date: isSet(object.date) ? DateMessage.fromJSON(object.date) : undefined,
      time: isSet(object.time) ? LocalTime.fromJSON(object.time) : undefined,
      offsetMinutes: isSet(object.offsetMinutes)
        ? globalThis.Number(object.offsetMinutes)
        : isSet(object.offset_minutes)
        ? globalThis.Number(object.offset_minutes)
        : 0,
    };
  },

  toJSON(message: ZonedDateTime): unknown {
    const obj: any = {};
    if (message.date !== undefined) {
      obj.date = DateMessage.toJSON(message.date);
    }
    if (message.time !== undefined) {
      obj.time = LocalTime.toJSON(message.time);
    }
    if (message.offsetMinutes !== 0) {
      obj.offsetMinutes = Math.round(message.offsetMinutes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ZonedDateTime>, I>>(base?: I): ZonedDateTime {
    return ZonedDateTime.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ZonedDateTime>, I>>(object: I): ZonedDateTime {
    const message = createBaseZonedDateTime();
    message.date = (object.date !== undefined && object.date !== null)
      ? DateMessage.fromPartial(object.date)
      : undefined;
    message.time = (object.time !== undefined && object.time !== null) ? LocalTime.fromPartial(object.time) : undefined;
    message.offsetMinutes = object.offsetMinutes ?? 0;
    return message;
  },
};

function createBaseDuration(): Duration {
  return { months: 0n, nanoseconds: 0n };
}

export const Duration: MessageFns<Duration> = {
  encode(message: Duration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.months !== 0n) {
      if (BigInt.asIntN(64, message.months) !== message.months) {
        throw new globalThis.Error("value provided for field message.months of type int64 too large");
      }
      writer.uint32(8).int64(message.months);
    }
    if (message.nanoseconds !== 0n) {
      if (BigInt.asIntN(64, message.nanoseconds) !== message.nanoseconds) {
        throw new globalThis.Error("value provided for field message.nanoseconds of type int64 too large");
      }
      writer.uint32(16).int64(message.nanoseconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Duration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.months = reader.int64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nanoseconds = reader.int64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Duration {
    return {
      months: isSet(object.months) ? BigInt(object.months) : 0n,
      nanoseconds: isSet(object.nanoseconds) ? BigInt(object.nanoseconds) : 0n,
    };
  },

  toJSON(message: Duration): unknown {
    const obj: any = {};
    if (message.months !== 0n) {
      obj.months = message.months.toString();
    }
    if (message.nanoseconds !== 0n) {
      obj.nanoseconds = message.nanoseconds.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Duration>, I>>(base?: I): Duration {
    return Duration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Duration>, I>>(object: I): Duration {
    const message = createBaseDuration();
    message.months = object.months ?? 0n;
    message.nanoseconds = object.nanoseconds ?? 0n;
    return message;
  },
};

function createBaseNode(): Node {
  return { id: new Uint8Array(0), labels: [], properties: {} };
}

export const Node: MessageFns<Node> = {
  encode(message: Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    for (const v of message.labels) {
      writer.uint32(18).string(v!);
    }
    globalThis.Object.entries(message.properties).forEach(([key, value]: [string, Value]) => {
      Node_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.labels.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = Node_PropertiesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.properties[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      labels: globalThis.Array.isArray(object?.labels) ? object.labels.map((e: any) => globalThis.String(e)) : [],
      properties: isObject(object.properties)
        ? (globalThis.Object.entries(object.properties) as [string, any][]).reduce(
          (acc: { [key: string]: Value }, [key, value]: [string, any]) => {
            acc[key] = Value.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.labels?.length) {
      obj.labels = message.labels;
    }
    if (message.properties) {
      const entries = globalThis.Object.entries(message.properties) as [string, Value][];
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = Value.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Node>, I>>(base?: I): Node {
    return Node.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Node>, I>>(object: I): Node {
    const message = createBaseNode();
    message.id = object.id ?? new Uint8Array(0);
    message.labels = object.labels?.map((e) => e) || [];
    message.properties = (globalThis.Object.entries(object.properties ?? {}) as [string, Value][]).reduce(
      (acc: { [key: string]: Value }, [key, value]: [string, Value]) => {
        if (value !== undefined) {
          acc[key] = Value.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseNode_PropertiesEntry(): Node_PropertiesEntry {
  return { key: "", value: undefined };
}

export const Node_PropertiesEntry: MessageFns<Node_PropertiesEntry> = {
  encode(message: Node_PropertiesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node_PropertiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Node_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Node_PropertiesEntry>, I>>(base?: I): Node_PropertiesEntry {
    return Node_PropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Node_PropertiesEntry>, I>>(object: I): Node_PropertiesEntry {
    const message = createBaseNode_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseEdge(): Edge {
  return {
    id: new Uint8Array(0),
    labels: [],
    sourceNodeId: new Uint8Array(0),
    targetNodeId: new Uint8Array(0),
    undirected: false,
    properties: {},
  };
}

export const Edge: MessageFns<Edge> = {
  encode(message: Edge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    for (const v of message.labels) {
      writer.uint32(18).string(v!);
    }
    if (message.sourceNodeId.length !== 0) {
      writer.uint32(26).bytes(message.sourceNodeId);
    }
    if (message.targetNodeId.length !== 0) {
      writer.uint32(34).bytes(message.targetNodeId);
    }
    if (message.undirected !== false) {
      writer.uint32(40).bool(message.undirected);
    }
    globalThis.Object.entries(message.properties).forEach(([key, value]: [string, Value]) => {
      Edge_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Edge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.labels.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceNodeId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.targetNodeId = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.undirected = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = Edge_PropertiesEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.properties[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Edge {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      labels: globalThis.Array.isArray(object?.labels) ? object.labels.map((e: any) => globalThis.String(e)) : [],
      sourceNodeId: isSet(object.sourceNodeId)
        ? bytesFromBase64(object.sourceNodeId)
        : isSet(object.source_node_id)
        ? bytesFromBase64(object.source_node_id)
        : new Uint8Array(0),
      targetNodeId: isSet(object.targetNodeId)
        ? bytesFromBase64(object.targetNodeId)
        : isSet(object.target_node_id)
        ? bytesFromBase64(object.target_node_id)
        : new Uint8Array(0),
      undirected: isSet(object.undirected) ? globalThis.Boolean(object.undirected) : false,
      properties: isObject(object.properties)
        ? (globalThis.Object.entries(object.properties) as [string, any][]).reduce(
          (acc: { [key: string]: Value }, [key, value]: [string, any]) => {
            acc[key] = Value.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: Edge): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.labels?.length) {
      obj.labels = message.labels;
    }
    if (message.sourceNodeId.length !== 0) {
      obj.sourceNodeId = base64FromBytes(message.sourceNodeId);
    }
    if (message.targetNodeId.length !== 0) {
      obj.targetNodeId = base64FromBytes(message.targetNodeId);
    }
    if (message.undirected !== false) {
      obj.undirected = message.undirected;
    }
    if (message.properties) {
      const entries = globalThis.Object.entries(message.properties) as [string, Value][];
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = Value.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Edge>, I>>(base?: I): Edge {
    return Edge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Edge>, I>>(object: I): Edge {
    const message = createBaseEdge();
    message.id = object.id ?? new Uint8Array(0);
    message.labels = object.labels?.map((e) => e) || [];
    message.sourceNodeId = object.sourceNodeId ?? new Uint8Array(0);
    message.targetNodeId = object.targetNodeId ?? new Uint8Array(0);
    message.undirected = object.undirected ?? false;
    message.properties = (globalThis.Object.entries(object.properties ?? {}) as [string, Value][]).reduce(
      (acc: { [key: string]: Value }, [key, value]: [string, Value]) => {
        if (value !== undefined) {
          acc[key] = Value.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseEdge_PropertiesEntry(): Edge_PropertiesEntry {
  return { key: "", value: undefined };
}

export const Edge_PropertiesEntry: MessageFns<Edge_PropertiesEntry> = {
  encode(message: Edge_PropertiesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Edge_PropertiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdge_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Edge_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Edge_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Edge_PropertiesEntry>, I>>(base?: I): Edge_PropertiesEntry {
    return Edge_PropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Edge_PropertiesEntry>, I>>(object: I): Edge_PropertiesEntry {
    const message = createBaseEdge_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBasePath(): Path {
  return { nodes: [], edges: [] };
}

export const Path: MessageFns<Path> = {
  encode(message: Path, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.edges) {
      Edge.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Path {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePath();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.edges.push(Edge.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Path {
    return {
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [],
      edges: globalThis.Array.isArray(object?.edges) ? object.edges.map((e: any) => Edge.fromJSON(e)) : [],
    };
  },

  toJSON(message: Path): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    if (message.edges?.length) {
      obj.edges = message.edges.map((e) => Edge.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Path>, I>>(base?: I): Path {
    return Path.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Path>, I>>(object: I): Path {
    const message = createBasePath();
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    message.edges = object.edges?.map((e) => Edge.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGqlList(): GqlList {
  return { elements: [] };
}

export const GqlList: MessageFns<GqlList> = {
  encode(message: GqlList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.elements) {
      Value.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GqlList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGqlList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.elements.push(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GqlList {
    return {
      elements: globalThis.Array.isArray(object?.elements) ? object.elements.map((e: any) => Value.fromJSON(e)) : [],
    };
  },

  toJSON(message: GqlList): unknown {
    const obj: any = {};
    if (message.elements?.length) {
      obj.elements = message.elements.map((e) => Value.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GqlList>, I>>(base?: I): GqlList {
    return GqlList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GqlList>, I>>(object: I): GqlList {
    const message = createBaseGqlList();
    message.elements = object.elements?.map((e) => Value.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRecord(): Record {
  return { fields: [] };
}

export const Record: MessageFns<Record> = {
  encode(message: Record, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fields) {
      Field.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Record {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fields.push(Field.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Record {
    return { fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => Field.fromJSON(e)) : [] };
  },

  toJSON(message: Record): unknown {
    const obj: any = {};
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => Field.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Record>, I>>(base?: I): Record {
    return Record.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Record>, I>>(object: I): Record {
    const message = createBaseRecord();
    message.fields = object.fields?.map((e) => Field.fromPartial(e)) || [];
    return message;
  },
};

function createBaseField(): Field {
  return { name: "", value: undefined };
}

export const Field: MessageFns<Field> = {
  encode(message: Field, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Field {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Field {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Field): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Field>, I>>(base?: I): Field {
    return Field.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Field>, I>>(object: I): Field {
    const message = createBaseField();
    message.name = object.name ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseTypeDescriptor(): TypeDescriptor {
  return { type: 0, nullable: false, elementType: undefined, fields: [] };
}

export const TypeDescriptor: MessageFns<TypeDescriptor> = {
  encode(message: TypeDescriptor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.nullable !== false) {
      writer.uint32(16).bool(message.nullable);
    }
    if (message.elementType !== undefined) {
      TypeDescriptor.encode(message.elementType, writer.uint32(26).fork()).join();
    }
    for (const v of message.fields) {
      FieldDescriptor.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TypeDescriptor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypeDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.elementType = TypeDescriptor.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fields.push(FieldDescriptor.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypeDescriptor {
    return {
      type: isSet(object.type) ? gqlTypeFromJSON(object.type) : 0,
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
      elementType: isSet(object.elementType)
        ? TypeDescriptor.fromJSON(object.elementType)
        : isSet(object.element_type)
        ? TypeDescriptor.fromJSON(object.element_type)
        : undefined,
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => FieldDescriptor.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TypeDescriptor): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = gqlTypeToJSON(message.type);
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.elementType !== undefined) {
      obj.elementType = TypeDescriptor.toJSON(message.elementType);
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => FieldDescriptor.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TypeDescriptor>, I>>(base?: I): TypeDescriptor {
    return TypeDescriptor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TypeDescriptor>, I>>(object: I): TypeDescriptor {
    const message = createBaseTypeDescriptor();
    message.type = object.type ?? 0;
    message.nullable = object.nullable ?? false;
    message.elementType = (object.elementType !== undefined && object.elementType !== null)
      ? TypeDescriptor.fromPartial(object.elementType)
      : undefined;
    message.fields = object.fields?.map((e) => FieldDescriptor.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFieldDescriptor(): FieldDescriptor {
  return { name: "", type: undefined };
}

export const FieldDescriptor: MessageFns<FieldDescriptor> = {
  encode(message: FieldDescriptor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== undefined) {
      TypeDescriptor.encode(message.type, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldDescriptor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = TypeDescriptor.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldDescriptor {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? TypeDescriptor.fromJSON(object.type) : undefined,
    };
  },

  toJSON(message: FieldDescriptor): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== undefined) {
      obj.type = TypeDescriptor.toJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldDescriptor>, I>>(base?: I): FieldDescriptor {
    return FieldDescriptor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldDescriptor>, I>>(object: I): FieldDescriptor {
    const message = createBaseFieldDescriptor();
    message.name = object.name ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? TypeDescriptor.fromPartial(object.type)
      : undefined;
    return message;
  },
};

function createBaseGqlStatus(): GqlStatus {
  return { code: "", message: "", diagnostic: undefined, cause: undefined };
}

export const GqlStatus: MessageFns<GqlStatus> = {
  encode(message: GqlStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.diagnostic !== undefined) {
      DiagnosticRecord.encode(message.diagnostic, writer.uint32(26).fork()).join();
    }
    if (message.cause !== undefined) {
      GqlStatus.encode(message.cause, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GqlStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGqlStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.diagnostic = DiagnosticRecord.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cause = GqlStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GqlStatus {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      diagnostic: isSet(object.diagnostic) ? DiagnosticRecord.fromJSON(object.diagnostic) : undefined,
      cause: isSet(object.cause) ? GqlStatus.fromJSON(object.cause) : undefined,
    };
  },

  toJSON(message: GqlStatus): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.diagnostic !== undefined) {
      obj.diagnostic = DiagnosticRecord.toJSON(message.diagnostic);
    }
    if (message.cause !== undefined) {
      obj.cause = GqlStatus.toJSON(message.cause);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GqlStatus>, I>>(base?: I): GqlStatus {
    return GqlStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GqlStatus>, I>>(object: I): GqlStatus {
    const message = createBaseGqlStatus();
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    message.diagnostic = (object.diagnostic !== undefined && object.diagnostic !== null)
      ? DiagnosticRecord.fromPartial(object.diagnostic)
      : undefined;
    message.cause = (object.cause !== undefined && object.cause !== null)
      ? GqlStatus.fromPartial(object.cause)
      : undefined;
    return message;
  },
};

function createBaseDiagnosticRecord(): DiagnosticRecord {
  return { operation: "", operationCode: 0, currentSchema: "" };
}

export const DiagnosticRecord: MessageFns<DiagnosticRecord> = {
  encode(message: DiagnosticRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== "") {
      writer.uint32(10).string(message.operation);
    }
    if (message.operationCode !== 0) {
      writer.uint32(16).int32(message.operationCode);
    }
    if (message.currentSchema !== "") {
      writer.uint32(26).string(message.currentSchema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiagnosticRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnosticRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operation = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operationCode = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currentSchema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiagnosticRecord {
    return {
      operation: isSet(object.operation) ? globalThis.String(object.operation) : "",
      operationCode: isSet(object.operationCode)
        ? globalThis.Number(object.operationCode)
        : isSet(object.operation_code)
        ? globalThis.Number(object.operation_code)
        : 0,
      currentSchema: isSet(object.currentSchema)
        ? globalThis.String(object.currentSchema)
        : isSet(object.current_schema)
        ? globalThis.String(object.current_schema)
        : "",
    };
  },

  toJSON(message: DiagnosticRecord): unknown {
    const obj: any = {};
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    if (message.operationCode !== 0) {
      obj.operationCode = Math.round(message.operationCode);
    }
    if (message.currentSchema !== "") {
      obj.currentSchema = message.currentSchema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiagnosticRecord>, I>>(base?: I): DiagnosticRecord {
    return DiagnosticRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiagnosticRecord>, I>>(object: I): DiagnosticRecord {
    const message = createBaseDiagnosticRecord();
    message.operation = object.operation ?? "";
    message.operationCode = object.operationCode ?? 0;
    message.currentSchema = object.currentSchema ?? "";
    return message;
  },
};

function createBaseAuthCredentials(): AuthCredentials {
  return { bearerToken: undefined, basic: undefined };
}

export const AuthCredentials: MessageFns<AuthCredentials> = {
  encode(message: AuthCredentials, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bearerToken !== undefined) {
      writer.uint32(10).string(message.bearerToken);
    }
    if (message.basic !== undefined) {
      BasicAuth.encode(message.basic, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthCredentials {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthCredentials();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bearerToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.basic = BasicAuth.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthCredentials {
    return {
      bearerToken: isSet(object.bearerToken)
        ? globalThis.String(object.bearerToken)
        : isSet(object.bearer_token)
        ? globalThis.String(object.bearer_token)
        : undefined,
      basic: isSet(object.basic) ? BasicAuth.fromJSON(object.basic) : undefined,
    };
  },

  toJSON(message: AuthCredentials): unknown {
    const obj: any = {};
    if (message.bearerToken !== undefined) {
      obj.bearerToken = message.bearerToken;
    }
    if (message.basic !== undefined) {
      obj.basic = BasicAuth.toJSON(message.basic);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthCredentials>, I>>(base?: I): AuthCredentials {
    return AuthCredentials.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthCredentials>, I>>(object: I): AuthCredentials {
    const message = createBaseAuthCredentials();
    message.bearerToken = object.bearerToken ?? undefined;
    message.basic = (object.basic !== undefined && object.basic !== null)
      ? BasicAuth.fromPartial(object.basic)
      : undefined;
    return message;
  },
};

function createBaseBasicAuth(): BasicAuth {
  return { username: "", password: "" };
}

export const BasicAuth: MessageFns<BasicAuth> = {
  encode(message: BasicAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasicAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasicAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasicAuth {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: BasicAuth): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasicAuth>, I>>(base?: I): BasicAuth {
    return BasicAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasicAuth>, I>>(object: I): BasicAuth {
    const message = createBaseBasicAuth();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
