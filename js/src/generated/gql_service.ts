// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.20.3
// source: gql_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { AuthCredentials, GqlStatus, TypeDescriptor, Value } from "./gql_types";

export const protobufPackage = "gql";

export enum ResetTarget {
  RESET_ALL = 0,
  RESET_SCHEMA = 1,
  RESET_GRAPH = 2,
  RESET_TIME_ZONE = 3,
  RESET_PARAMETERS = 4,
  UNRECOGNIZED = -1,
}

export function resetTargetFromJSON(object: any): ResetTarget {
  switch (object) {
    case 0:
    case "RESET_ALL":
      return ResetTarget.RESET_ALL;
    case 1:
    case "RESET_SCHEMA":
      return ResetTarget.RESET_SCHEMA;
    case 2:
    case "RESET_GRAPH":
      return ResetTarget.RESET_GRAPH;
    case 3:
    case "RESET_TIME_ZONE":
      return ResetTarget.RESET_TIME_ZONE;
    case 4:
    case "RESET_PARAMETERS":
      return ResetTarget.RESET_PARAMETERS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResetTarget.UNRECOGNIZED;
  }
}

export function resetTargetToJSON(object: ResetTarget): string {
  switch (object) {
    case ResetTarget.RESET_ALL:
      return "RESET_ALL";
    case ResetTarget.RESET_SCHEMA:
      return "RESET_SCHEMA";
    case ResetTarget.RESET_GRAPH:
      return "RESET_GRAPH";
    case ResetTarget.RESET_TIME_ZONE:
      return "RESET_TIME_ZONE";
    case ResetTarget.RESET_PARAMETERS:
      return "RESET_PARAMETERS";
    case ResetTarget.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ResultType {
  BINDING_TABLE = 0,
  GRAPH = 1,
  OMITTED = 2,
  UNRECOGNIZED = -1,
}

export function resultTypeFromJSON(object: any): ResultType {
  switch (object) {
    case 0:
    case "BINDING_TABLE":
      return ResultType.BINDING_TABLE;
    case 1:
    case "GRAPH":
      return ResultType.GRAPH;
    case 2:
    case "OMITTED":
      return ResultType.OMITTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResultType.UNRECOGNIZED;
  }
}

export function resultTypeToJSON(object: ResultType): string {
  switch (object) {
    case ResultType.BINDING_TABLE:
      return "BINDING_TABLE";
    case ResultType.GRAPH:
      return "GRAPH";
    case ResultType.OMITTED:
      return "OMITTED";
    case ResultType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TransactionMode {
  READ_WRITE = 0,
  READ_ONLY = 1,
  UNRECOGNIZED = -1,
}

export function transactionModeFromJSON(object: any): TransactionMode {
  switch (object) {
    case 0:
    case "READ_WRITE":
      return TransactionMode.READ_WRITE;
    case 1:
    case "READ_ONLY":
      return TransactionMode.READ_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionMode.UNRECOGNIZED;
  }
}

export function transactionModeToJSON(object: TransactionMode): string {
  switch (object) {
    case TransactionMode.READ_WRITE:
      return "READ_WRITE";
    case TransactionMode.READ_ONLY:
      return "READ_ONLY";
    case TransactionMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface HandshakeRequest {
  protocolVersion: number;
  credentials:
    | AuthCredentials
    | undefined;
  /** Driver name, version, platform */
  clientInfo: { [key: string]: string };
}

export interface HandshakeRequest_ClientInfoEntry {
  key: string;
  value: string;
}

export interface HandshakeResponse {
  protocolVersion: number;
  sessionId: string;
  serverInfo:
    | ServerInfo
    | undefined;
  /** Implementation limits (IL codes) */
  limits: { [key: string]: bigint };
}

export interface HandshakeResponse_LimitsEntry {
  key: string;
  value: bigint;
}

export interface ServerInfo {
  name: string;
  version: string;
  features: string[];
}

export interface ConfigureRequest {
  sessionId: string;
  schema?: string | undefined;
  graph?: string | undefined;
  timeZoneOffsetMinutes?: number | undefined;
  parameter?: SessionParameter | undefined;
}

export interface SessionParameter {
  name: string;
  value: Value | undefined;
}

export interface ConfigureResponse {
}

export interface ResetRequest {
  sessionId: string;
  target: ResetTarget;
}

export interface ResetResponse {
}

export interface CloseRequest {
  sessionId: string;
}

export interface CloseResponse {
}

export interface PingRequest {
  sessionId: string;
}

export interface PongResponse {
  timestamp: bigint;
}

export interface ExecuteRequest {
  sessionId: string;
  statement: string;
  parameters: { [key: string]: Value };
  /** Omit for auto-commit */
  transactionId?: string | undefined;
}

export interface ExecuteRequest_ParametersEntry {
  key: string;
  value: Value | undefined;
}

export interface ExecuteResponse {
  header?: ResultHeader | undefined;
  rowBatch?: RowBatch | undefined;
  summary?: ResultSummary | undefined;
}

/** First frame: describes what kind of result follows. */
export interface ResultHeader {
  resultType: ResultType;
  columns: ColumnDescriptor[];
}

export interface ColumnDescriptor {
  name: string;
  type: TypeDescriptor | undefined;
}

/** Data frames: batched rows. */
export interface RowBatch {
  rows: Row[];
}

export interface Row {
  /** Positional, matches column order from header */
  values: Value[];
}

/** Final frame: completion status and statistics. */
export interface ResultSummary {
  status: GqlStatus | undefined;
  warnings: GqlStatus[];
  rowsAffected: bigint;
  /** nodes_created, edges_deleted, etc. */
  counters: { [key: string]: bigint };
}

export interface ResultSummary_CountersEntry {
  key: string;
  value: bigint;
}

export interface BeginRequest {
  sessionId: string;
  mode: TransactionMode;
}

export interface BeginResponse {
  transactionId: string;
  status: GqlStatus | undefined;
}

export interface CommitRequest {
  sessionId: string;
  transactionId: string;
}

export interface CommitResponse {
  status: GqlStatus | undefined;
}

export interface RollbackRequest {
  sessionId: string;
  transactionId: string;
}

export interface RollbackResponse {
  status: GqlStatus | undefined;
}

export interface ListDatabasesRequest {
}

export interface DatabaseSummary {
  name: string;
  nodeCount: bigint;
  edgeCount: bigint;
  persistent: boolean;
  databaseType: string;
}

export interface ListDatabasesResponse {
  databases: DatabaseSummary[];
}

export interface CreateDatabaseRequest {
  name: string;
  /** "Lpg", "Rdf", etc. */
  databaseType: string;
  /** "InMemory" or "Persistent" */
  storageMode: string;
  options: DatabaseOptions | undefined;
}

export interface DatabaseOptions {
  memoryLimitBytes?: bigint | undefined;
  backwardEdges?: boolean | undefined;
  threads?: number | undefined;
  walEnabled?: boolean | undefined;
  walDurability?: string | undefined;
}

export interface CreateDatabaseResponse {
  database: DatabaseSummary | undefined;
}

export interface DeleteDatabaseRequest {
  name: string;
}

export interface DeleteDatabaseResponse {
  deleted: string;
}

export interface GetDatabaseInfoRequest {
  name: string;
}

export interface GetDatabaseInfoResponse {
  name: string;
  nodeCount: bigint;
  edgeCount: bigint;
  persistent: boolean;
  databaseType: string;
  storageMode: string;
  memoryLimitBytes: bigint;
  backwardEdges: boolean;
  threads: number;
}

function createBaseHandshakeRequest(): HandshakeRequest {
  return { protocolVersion: 0, credentials: undefined, clientInfo: {} };
}

export const HandshakeRequest: MessageFns<HandshakeRequest> = {
  encode(message: HandshakeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocolVersion !== 0) {
      writer.uint32(8).uint32(message.protocolVersion);
    }
    if (message.credentials !== undefined) {
      AuthCredentials.encode(message.credentials, writer.uint32(18).fork()).join();
    }
    globalThis.Object.entries(message.clientInfo).forEach(([key, value]: [string, string]) => {
      HandshakeRequest_ClientInfoEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandshakeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandshakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.protocolVersion = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.credentials = AuthCredentials.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = HandshakeRequest_ClientInfoEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.clientInfo[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandshakeRequest {
    return {
      protocolVersion: isSet(object.protocolVersion)
        ? globalThis.Number(object.protocolVersion)
        : isSet(object.protocol_version)
        ? globalThis.Number(object.protocol_version)
        : 0,
      credentials: isSet(object.credentials) ? AuthCredentials.fromJSON(object.credentials) : undefined,
      clientInfo: isObject(object.clientInfo)
        ? (globalThis.Object.entries(object.clientInfo) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : isObject(object.client_info)
        ? (globalThis.Object.entries(object.client_info) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: HandshakeRequest): unknown {
    const obj: any = {};
    if (message.protocolVersion !== 0) {
      obj.protocolVersion = Math.round(message.protocolVersion);
    }
    if (message.credentials !== undefined) {
      obj.credentials = AuthCredentials.toJSON(message.credentials);
    }
    if (message.clientInfo) {
      const entries = globalThis.Object.entries(message.clientInfo) as [string, string][];
      if (entries.length > 0) {
        obj.clientInfo = {};
        entries.forEach(([k, v]) => {
          obj.clientInfo[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HandshakeRequest>, I>>(base?: I): HandshakeRequest {
    return HandshakeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandshakeRequest>, I>>(object: I): HandshakeRequest {
    const message = createBaseHandshakeRequest();
    message.protocolVersion = object.protocolVersion ?? 0;
    message.credentials = (object.credentials !== undefined && object.credentials !== null)
      ? AuthCredentials.fromPartial(object.credentials)
      : undefined;
    message.clientInfo = (globalThis.Object.entries(object.clientInfo ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseHandshakeRequest_ClientInfoEntry(): HandshakeRequest_ClientInfoEntry {
  return { key: "", value: "" };
}

export const HandshakeRequest_ClientInfoEntry: MessageFns<HandshakeRequest_ClientInfoEntry> = {
  encode(message: HandshakeRequest_ClientInfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandshakeRequest_ClientInfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandshakeRequest_ClientInfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandshakeRequest_ClientInfoEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HandshakeRequest_ClientInfoEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HandshakeRequest_ClientInfoEntry>, I>>(
    base?: I,
  ): HandshakeRequest_ClientInfoEntry {
    return HandshakeRequest_ClientInfoEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandshakeRequest_ClientInfoEntry>, I>>(
    object: I,
  ): HandshakeRequest_ClientInfoEntry {
    const message = createBaseHandshakeRequest_ClientInfoEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHandshakeResponse(): HandshakeResponse {
  return { protocolVersion: 0, sessionId: "", serverInfo: undefined, limits: {} };
}

export const HandshakeResponse: MessageFns<HandshakeResponse> = {
  encode(message: HandshakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocolVersion !== 0) {
      writer.uint32(8).uint32(message.protocolVersion);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.serverInfo !== undefined) {
      ServerInfo.encode(message.serverInfo, writer.uint32(26).fork()).join();
    }
    globalThis.Object.entries(message.limits).forEach(([key, value]: [string, bigint]) => {
      HandshakeResponse_LimitsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandshakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandshakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.protocolVersion = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serverInfo = ServerInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = HandshakeResponse_LimitsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.limits[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandshakeResponse {
    return {
      protocolVersion: isSet(object.protocolVersion)
        ? globalThis.Number(object.protocolVersion)
        : isSet(object.protocol_version)
        ? globalThis.Number(object.protocol_version)
        : 0,
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      serverInfo: isSet(object.serverInfo)
        ? ServerInfo.fromJSON(object.serverInfo)
        : isSet(object.server_info)
        ? ServerInfo.fromJSON(object.server_info)
        : undefined,
      limits: isObject(object.limits)
        ? (globalThis.Object.entries(object.limits) as [string, any][]).reduce(
          (acc: { [key: string]: bigint }, [key, value]: [string, any]) => {
            acc[key] = BigInt(value as string | number | bigint | boolean);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: HandshakeResponse): unknown {
    const obj: any = {};
    if (message.protocolVersion !== 0) {
      obj.protocolVersion = Math.round(message.protocolVersion);
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.serverInfo !== undefined) {
      obj.serverInfo = ServerInfo.toJSON(message.serverInfo);
    }
    if (message.limits) {
      const entries = globalThis.Object.entries(message.limits) as [string, bigint][];
      if (entries.length > 0) {
        obj.limits = {};
        entries.forEach(([k, v]) => {
          obj.limits[k] = v.toString();
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HandshakeResponse>, I>>(base?: I): HandshakeResponse {
    return HandshakeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandshakeResponse>, I>>(object: I): HandshakeResponse {
    const message = createBaseHandshakeResponse();
    message.protocolVersion = object.protocolVersion ?? 0;
    message.sessionId = object.sessionId ?? "";
    message.serverInfo = (object.serverInfo !== undefined && object.serverInfo !== null)
      ? ServerInfo.fromPartial(object.serverInfo)
      : undefined;
    message.limits = (globalThis.Object.entries(object.limits ?? {}) as [string, bigint][]).reduce(
      (acc: { [key: string]: bigint }, [key, value]: [string, bigint]) => {
        if (value !== undefined) {
          acc[key] = BigInt(value as string | number | bigint | boolean);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseHandshakeResponse_LimitsEntry(): HandshakeResponse_LimitsEntry {
  return { key: "", value: 0n };
}

export const HandshakeResponse_LimitsEntry: MessageFns<HandshakeResponse_LimitsEntry> = {
  encode(message: HandshakeResponse_LimitsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0n) {
      if (BigInt.asIntN(64, message.value) !== message.value) {
        throw new globalThis.Error("value provided for field message.value of type int64 too large");
      }
      writer.uint32(16).int64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandshakeResponse_LimitsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandshakeResponse_LimitsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandshakeResponse_LimitsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? BigInt(object.value) : 0n,
    };
  },

  toJSON(message: HandshakeResponse_LimitsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0n) {
      obj.value = message.value.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HandshakeResponse_LimitsEntry>, I>>(base?: I): HandshakeResponse_LimitsEntry {
    return HandshakeResponse_LimitsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandshakeResponse_LimitsEntry>, I>>(
    object: I,
  ): HandshakeResponse_LimitsEntry {
    const message = createBaseHandshakeResponse_LimitsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0n;
    return message;
  },
};

function createBaseServerInfo(): ServerInfo {
  return { name: "", version: "", features: [] };
}

export const ServerInfo: MessageFns<ServerInfo> = {
  encode(message: ServerInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    for (const v of message.features) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.features.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      features: globalThis.Array.isArray(object?.features) ? object.features.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ServerInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.features?.length) {
      obj.features = message.features;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerInfo>, I>>(base?: I): ServerInfo {
    return ServerInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerInfo>, I>>(object: I): ServerInfo {
    const message = createBaseServerInfo();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.features = object.features?.map((e) => e) || [];
    return message;
  },
};

function createBaseConfigureRequest(): ConfigureRequest {
  return { sessionId: "", schema: undefined, graph: undefined, timeZoneOffsetMinutes: undefined, parameter: undefined };
}

export const ConfigureRequest: MessageFns<ConfigureRequest> = {
  encode(message: ConfigureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.schema !== undefined) {
      writer.uint32(18).string(message.schema);
    }
    if (message.graph !== undefined) {
      writer.uint32(26).string(message.graph);
    }
    if (message.timeZoneOffsetMinutes !== undefined) {
      writer.uint32(32).int32(message.timeZoneOffsetMinutes);
    }
    if (message.parameter !== undefined) {
      SessionParameter.encode(message.parameter, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.graph = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timeZoneOffsetMinutes = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.parameter = SessionParameter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigureRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : undefined,
      graph: isSet(object.graph) ? globalThis.String(object.graph) : undefined,
      timeZoneOffsetMinutes: isSet(object.timeZoneOffsetMinutes)
        ? globalThis.Number(object.timeZoneOffsetMinutes)
        : isSet(object.time_zone_offset_minutes)
        ? globalThis.Number(object.time_zone_offset_minutes)
        : undefined,
      parameter: isSet(object.parameter) ? SessionParameter.fromJSON(object.parameter) : undefined,
    };
  },

  toJSON(message: ConfigureRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.schema !== undefined) {
      obj.schema = message.schema;
    }
    if (message.graph !== undefined) {
      obj.graph = message.graph;
    }
    if (message.timeZoneOffsetMinutes !== undefined) {
      obj.timeZoneOffsetMinutes = Math.round(message.timeZoneOffsetMinutes);
    }
    if (message.parameter !== undefined) {
      obj.parameter = SessionParameter.toJSON(message.parameter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigureRequest>, I>>(base?: I): ConfigureRequest {
    return ConfigureRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigureRequest>, I>>(object: I): ConfigureRequest {
    const message = createBaseConfigureRequest();
    message.sessionId = object.sessionId ?? "";
    message.schema = object.schema ?? undefined;
    message.graph = object.graph ?? undefined;
    message.timeZoneOffsetMinutes = object.timeZoneOffsetMinutes ?? undefined;
    message.parameter = (object.parameter !== undefined && object.parameter !== null)
      ? SessionParameter.fromPartial(object.parameter)
      : undefined;
    return message;
  },
};

function createBaseSessionParameter(): SessionParameter {
  return { name: "", value: undefined };
}

export const SessionParameter: MessageFns<SessionParameter> = {
  encode(message: SessionParameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionParameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionParameter {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SessionParameter): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionParameter>, I>>(base?: I): SessionParameter {
    return SessionParameter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionParameter>, I>>(object: I): SessionParameter {
    const message = createBaseSessionParameter();
    message.name = object.name ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseConfigureResponse(): ConfigureResponse {
  return {};
}

export const ConfigureResponse: MessageFns<ConfigureResponse> = {
  encode(_: ConfigureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ConfigureResponse {
    return {};
  },

  toJSON(_: ConfigureResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigureResponse>, I>>(base?: I): ConfigureResponse {
    return ConfigureResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigureResponse>, I>>(_: I): ConfigureResponse {
    const message = createBaseConfigureResponse();
    return message;
  },
};

function createBaseResetRequest(): ResetRequest {
  return { sessionId: "", target: 0 };
}

export const ResetRequest: MessageFns<ResetRequest> = {
  encode(message: ResetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.target !== 0) {
      writer.uint32(16).int32(message.target);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      target: isSet(object.target) ? resetTargetFromJSON(object.target) : 0,
    };
  },

  toJSON(message: ResetRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.target !== 0) {
      obj.target = resetTargetToJSON(message.target);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetRequest>, I>>(base?: I): ResetRequest {
    return ResetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetRequest>, I>>(object: I): ResetRequest {
    const message = createBaseResetRequest();
    message.sessionId = object.sessionId ?? "";
    message.target = object.target ?? 0;
    return message;
  },
};

function createBaseResetResponse(): ResetResponse {
  return {};
}

export const ResetResponse: MessageFns<ResetResponse> = {
  encode(_: ResetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResetResponse {
    return {};
  },

  toJSON(_: ResetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetResponse>, I>>(base?: I): ResetResponse {
    return ResetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetResponse>, I>>(_: I): ResetResponse {
    const message = createBaseResetResponse();
    return message;
  },
};

function createBaseCloseRequest(): CloseRequest {
  return { sessionId: "" };
}

export const CloseRequest: MessageFns<CloseRequest> = {
  encode(message: CloseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloseRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
    };
  },

  toJSON(message: CloseRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloseRequest>, I>>(base?: I): CloseRequest {
    return CloseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloseRequest>, I>>(object: I): CloseRequest {
    const message = createBaseCloseRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseCloseResponse(): CloseResponse {
  return {};
}

export const CloseResponse: MessageFns<CloseResponse> = {
  encode(_: CloseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CloseResponse {
    return {};
  },

  toJSON(_: CloseResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CloseResponse>, I>>(base?: I): CloseResponse {
    return CloseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloseResponse>, I>>(_: I): CloseResponse {
    const message = createBaseCloseResponse();
    return message;
  },
};

function createBasePingRequest(): PingRequest {
  return { sessionId: "" };
}

export const PingRequest: MessageFns<PingRequest> = {
  encode(message: PingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PingRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
    };
  },

  toJSON(message: PingRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PingRequest>, I>>(base?: I): PingRequest {
    return PingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PingRequest>, I>>(object: I): PingRequest {
    const message = createBasePingRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBasePongResponse(): PongResponse {
  return { timestamp: 0n };
}

export const PongResponse: MessageFns<PongResponse> = {
  encode(message: PongResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== 0n) {
      if (BigInt.asIntN(64, message.timestamp) !== message.timestamp) {
        throw new globalThis.Error("value provided for field message.timestamp of type int64 too large");
      }
      writer.uint32(8).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PongResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePongResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = reader.int64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PongResponse {
    return { timestamp: isSet(object.timestamp) ? BigInt(object.timestamp) : 0n };
  },

  toJSON(message: PongResponse): unknown {
    const obj: any = {};
    if (message.timestamp !== 0n) {
      obj.timestamp = message.timestamp.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PongResponse>, I>>(base?: I): PongResponse {
    return PongResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PongResponse>, I>>(object: I): PongResponse {
    const message = createBasePongResponse();
    message.timestamp = object.timestamp ?? 0n;
    return message;
  },
};

function createBaseExecuteRequest(): ExecuteRequest {
  return { sessionId: "", statement: "", parameters: {}, transactionId: undefined };
}

export const ExecuteRequest: MessageFns<ExecuteRequest> = {
  encode(message: ExecuteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.statement !== "") {
      writer.uint32(18).string(message.statement);
    }
    globalThis.Object.entries(message.parameters).forEach(([key, value]: [string, Value]) => {
      ExecuteRequest_ParametersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.transactionId !== undefined) {
      writer.uint32(34).string(message.transactionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statement = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ExecuteRequest_ParametersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.parameters[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      statement: isSet(object.statement) ? globalThis.String(object.statement) : "",
      parameters: isObject(object.parameters)
        ? (globalThis.Object.entries(object.parameters) as [string, any][]).reduce(
          (acc: { [key: string]: Value }, [key, value]: [string, any]) => {
            acc[key] = Value.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      transactionId: isSet(object.transactionId)
        ? globalThis.String(object.transactionId)
        : isSet(object.transaction_id)
        ? globalThis.String(object.transaction_id)
        : undefined,
    };
  },

  toJSON(message: ExecuteRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.statement !== "") {
      obj.statement = message.statement;
    }
    if (message.parameters) {
      const entries = globalThis.Object.entries(message.parameters) as [string, Value][];
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = Value.toJSON(v);
        });
      }
    }
    if (message.transactionId !== undefined) {
      obj.transactionId = message.transactionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteRequest>, I>>(base?: I): ExecuteRequest {
    return ExecuteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteRequest>, I>>(object: I): ExecuteRequest {
    const message = createBaseExecuteRequest();
    message.sessionId = object.sessionId ?? "";
    message.statement = object.statement ?? "";
    message.parameters = (globalThis.Object.entries(object.parameters ?? {}) as [string, Value][]).reduce(
      (acc: { [key: string]: Value }, [key, value]: [string, Value]) => {
        if (value !== undefined) {
          acc[key] = Value.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.transactionId = object.transactionId ?? undefined;
    return message;
  },
};

function createBaseExecuteRequest_ParametersEntry(): ExecuteRequest_ParametersEntry {
  return { key: "", value: undefined };
}

export const ExecuteRequest_ParametersEntry: MessageFns<ExecuteRequest_ParametersEntry> = {
  encode(message: ExecuteRequest_ParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteRequest_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteRequest_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteRequest_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ExecuteRequest_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteRequest_ParametersEntry>, I>>(base?: I): ExecuteRequest_ParametersEntry {
    return ExecuteRequest_ParametersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteRequest_ParametersEntry>, I>>(
    object: I,
  ): ExecuteRequest_ParametersEntry {
    const message = createBaseExecuteRequest_ParametersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseExecuteResponse(): ExecuteResponse {
  return { header: undefined, rowBatch: undefined, summary: undefined };
}

export const ExecuteResponse: MessageFns<ExecuteResponse> = {
  encode(message: ExecuteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      ResultHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.rowBatch !== undefined) {
      RowBatch.encode(message.rowBatch, writer.uint32(18).fork()).join();
    }
    if (message.summary !== undefined) {
      ResultSummary.encode(message.summary, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = ResultHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rowBatch = RowBatch.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.summary = ResultSummary.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteResponse {
    return {
      header: isSet(object.header) ? ResultHeader.fromJSON(object.header) : undefined,
      rowBatch: isSet(object.rowBatch)
        ? RowBatch.fromJSON(object.rowBatch)
        : isSet(object.row_batch)
        ? RowBatch.fromJSON(object.row_batch)
        : undefined,
      summary: isSet(object.summary) ? ResultSummary.fromJSON(object.summary) : undefined,
    };
  },

  toJSON(message: ExecuteResponse): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = ResultHeader.toJSON(message.header);
    }
    if (message.rowBatch !== undefined) {
      obj.rowBatch = RowBatch.toJSON(message.rowBatch);
    }
    if (message.summary !== undefined) {
      obj.summary = ResultSummary.toJSON(message.summary);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteResponse>, I>>(base?: I): ExecuteResponse {
    return ExecuteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteResponse>, I>>(object: I): ExecuteResponse {
    const message = createBaseExecuteResponse();
    message.header = (object.header !== undefined && object.header !== null)
      ? ResultHeader.fromPartial(object.header)
      : undefined;
    message.rowBatch = (object.rowBatch !== undefined && object.rowBatch !== null)
      ? RowBatch.fromPartial(object.rowBatch)
      : undefined;
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? ResultSummary.fromPartial(object.summary)
      : undefined;
    return message;
  },
};

function createBaseResultHeader(): ResultHeader {
  return { resultType: 0, columns: [] };
}

export const ResultHeader: MessageFns<ResultHeader> = {
  encode(message: ResultHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resultType !== 0) {
      writer.uint32(8).int32(message.resultType);
    }
    for (const v of message.columns) {
      ColumnDescriptor.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.resultType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.columns.push(ColumnDescriptor.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultHeader {
    return {
      resultType: isSet(object.resultType)
        ? resultTypeFromJSON(object.resultType)
        : isSet(object.result_type)
        ? resultTypeFromJSON(object.result_type)
        : 0,
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => ColumnDescriptor.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ResultHeader): unknown {
    const obj: any = {};
    if (message.resultType !== 0) {
      obj.resultType = resultTypeToJSON(message.resultType);
    }
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => ColumnDescriptor.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultHeader>, I>>(base?: I): ResultHeader {
    return ResultHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultHeader>, I>>(object: I): ResultHeader {
    const message = createBaseResultHeader();
    message.resultType = object.resultType ?? 0;
    message.columns = object.columns?.map((e) => ColumnDescriptor.fromPartial(e)) || [];
    return message;
  },
};

function createBaseColumnDescriptor(): ColumnDescriptor {
  return { name: "", type: undefined };
}

export const ColumnDescriptor: MessageFns<ColumnDescriptor> = {
  encode(message: ColumnDescriptor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== undefined) {
      TypeDescriptor.encode(message.type, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnDescriptor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = TypeDescriptor.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnDescriptor {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? TypeDescriptor.fromJSON(object.type) : undefined,
    };
  },

  toJSON(message: ColumnDescriptor): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== undefined) {
      obj.type = TypeDescriptor.toJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ColumnDescriptor>, I>>(base?: I): ColumnDescriptor {
    return ColumnDescriptor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ColumnDescriptor>, I>>(object: I): ColumnDescriptor {
    const message = createBaseColumnDescriptor();
    message.name = object.name ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? TypeDescriptor.fromPartial(object.type)
      : undefined;
    return message;
  },
};

function createBaseRowBatch(): RowBatch {
  return { rows: [] };
}

export const RowBatch: MessageFns<RowBatch> = {
  encode(message: RowBatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rows) {
      Row.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RowBatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRowBatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rows.push(Row.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RowBatch {
    return { rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => Row.fromJSON(e)) : [] };
  },

  toJSON(message: RowBatch): unknown {
    const obj: any = {};
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => Row.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RowBatch>, I>>(base?: I): RowBatch {
    return RowBatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RowBatch>, I>>(object: I): RowBatch {
    const message = createBaseRowBatch();
    message.rows = object.rows?.map((e) => Row.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRow(): Row {
  return { values: [] };
}

export const Row: MessageFns<Row> = {
  encode(message: Row, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      Value.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Row {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.values.push(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Row {
    return { values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => Value.fromJSON(e)) : [] };
  },

  toJSON(message: Row): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Value.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Row>, I>>(base?: I): Row {
    return Row.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Row>, I>>(object: I): Row {
    const message = createBaseRow();
    message.values = object.values?.map((e) => Value.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResultSummary(): ResultSummary {
  return { status: undefined, warnings: [], rowsAffected: 0n, counters: {} };
}

export const ResultSummary: MessageFns<ResultSummary> = {
  encode(message: ResultSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      GqlStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.warnings) {
      GqlStatus.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.rowsAffected !== 0n) {
      if (BigInt.asIntN(64, message.rowsAffected) !== message.rowsAffected) {
        throw new globalThis.Error("value provided for field message.rowsAffected of type int64 too large");
      }
      writer.uint32(24).int64(message.rowsAffected);
    }
    globalThis.Object.entries(message.counters).forEach(([key, value]: [string, bigint]) => {
      ResultSummary_CountersEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = GqlStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.warnings.push(GqlStatus.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rowsAffected = reader.int64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ResultSummary_CountersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.counters[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultSummary {
    return {
      status: isSet(object.status) ? GqlStatus.fromJSON(object.status) : undefined,
      warnings: globalThis.Array.isArray(object?.warnings)
        ? object.warnings.map((e: any) => GqlStatus.fromJSON(e))
        : [],
      rowsAffected: isSet(object.rowsAffected)
        ? BigInt(object.rowsAffected)
        : isSet(object.rows_affected)
        ? BigInt(object.rows_affected)
        : 0n,
      counters: isObject(object.counters)
        ? (globalThis.Object.entries(object.counters) as [string, any][]).reduce(
          (acc: { [key: string]: bigint }, [key, value]: [string, any]) => {
            acc[key] = BigInt(value as string | number | bigint | boolean);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: ResultSummary): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = GqlStatus.toJSON(message.status);
    }
    if (message.warnings?.length) {
      obj.warnings = message.warnings.map((e) => GqlStatus.toJSON(e));
    }
    if (message.rowsAffected !== 0n) {
      obj.rowsAffected = message.rowsAffected.toString();
    }
    if (message.counters) {
      const entries = globalThis.Object.entries(message.counters) as [string, bigint][];
      if (entries.length > 0) {
        obj.counters = {};
        entries.forEach(([k, v]) => {
          obj.counters[k] = v.toString();
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultSummary>, I>>(base?: I): ResultSummary {
    return ResultSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultSummary>, I>>(object: I): ResultSummary {
    const message = createBaseResultSummary();
    message.status = (object.status !== undefined && object.status !== null)
      ? GqlStatus.fromPartial(object.status)
      : undefined;
    message.warnings = object.warnings?.map((e) => GqlStatus.fromPartial(e)) || [];
    message.rowsAffected = object.rowsAffected ?? 0n;
    message.counters = (globalThis.Object.entries(object.counters ?? {}) as [string, bigint][]).reduce(
      (acc: { [key: string]: bigint }, [key, value]: [string, bigint]) => {
        if (value !== undefined) {
          acc[key] = BigInt(value as string | number | bigint | boolean);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseResultSummary_CountersEntry(): ResultSummary_CountersEntry {
  return { key: "", value: 0n };
}

export const ResultSummary_CountersEntry: MessageFns<ResultSummary_CountersEntry> = {
  encode(message: ResultSummary_CountersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0n) {
      if (BigInt.asIntN(64, message.value) !== message.value) {
        throw new globalThis.Error("value provided for field message.value of type int64 too large");
      }
      writer.uint32(16).int64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultSummary_CountersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultSummary_CountersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultSummary_CountersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? BigInt(object.value) : 0n,
    };
  },

  toJSON(message: ResultSummary_CountersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0n) {
      obj.value = message.value.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultSummary_CountersEntry>, I>>(base?: I): ResultSummary_CountersEntry {
    return ResultSummary_CountersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultSummary_CountersEntry>, I>>(object: I): ResultSummary_CountersEntry {
    const message = createBaseResultSummary_CountersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0n;
    return message;
  },
};

function createBaseBeginRequest(): BeginRequest {
  return { sessionId: "", mode: 0 };
}

export const BeginRequest: MessageFns<BeginRequest> = {
  encode(message: BeginRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.mode !== 0) {
      writer.uint32(16).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BeginRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBeginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BeginRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      mode: isSet(object.mode) ? transactionModeFromJSON(object.mode) : 0,
    };
  },

  toJSON(message: BeginRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.mode !== 0) {
      obj.mode = transactionModeToJSON(message.mode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BeginRequest>, I>>(base?: I): BeginRequest {
    return BeginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BeginRequest>, I>>(object: I): BeginRequest {
    const message = createBaseBeginRequest();
    message.sessionId = object.sessionId ?? "";
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseBeginResponse(): BeginResponse {
  return { transactionId: "", status: undefined };
}

export const BeginResponse: MessageFns<BeginResponse> = {
  encode(message: BeginResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== "") {
      writer.uint32(10).string(message.transactionId);
    }
    if (message.status !== undefined) {
      GqlStatus.encode(message.status, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BeginResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBeginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = GqlStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BeginResponse {
    return {
      transactionId: isSet(object.transactionId)
        ? globalThis.String(object.transactionId)
        : isSet(object.transaction_id)
        ? globalThis.String(object.transaction_id)
        : "",
      status: isSet(object.status) ? GqlStatus.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: BeginResponse): unknown {
    const obj: any = {};
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.status !== undefined) {
      obj.status = GqlStatus.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BeginResponse>, I>>(base?: I): BeginResponse {
    return BeginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BeginResponse>, I>>(object: I): BeginResponse {
    const message = createBaseBeginResponse();
    message.transactionId = object.transactionId ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? GqlStatus.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseCommitRequest(): CommitRequest {
  return { sessionId: "", transactionId: "" };
}

export const CommitRequest: MessageFns<CommitRequest> = {
  encode(message: CommitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.transactionId !== "") {
      writer.uint32(18).string(message.transactionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      transactionId: isSet(object.transactionId)
        ? globalThis.String(object.transactionId)
        : isSet(object.transaction_id)
        ? globalThis.String(object.transaction_id)
        : "",
    };
  },

  toJSON(message: CommitRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommitRequest>, I>>(base?: I): CommitRequest {
    return CommitRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommitRequest>, I>>(object: I): CommitRequest {
    const message = createBaseCommitRequest();
    message.sessionId = object.sessionId ?? "";
    message.transactionId = object.transactionId ?? "";
    return message;
  },
};

function createBaseCommitResponse(): CommitResponse {
  return { status: undefined };
}

export const CommitResponse: MessageFns<CommitResponse> = {
  encode(message: CommitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      GqlStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = GqlStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitResponse {
    return { status: isSet(object.status) ? GqlStatus.fromJSON(object.status) : undefined };
  },

  toJSON(message: CommitResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = GqlStatus.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommitResponse>, I>>(base?: I): CommitResponse {
    return CommitResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommitResponse>, I>>(object: I): CommitResponse {
    const message = createBaseCommitResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? GqlStatus.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseRollbackRequest(): RollbackRequest {
  return { sessionId: "", transactionId: "" };
}

export const RollbackRequest: MessageFns<RollbackRequest> = {
  encode(message: RollbackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.transactionId !== "") {
      writer.uint32(18).string(message.transactionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RollbackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RollbackRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      transactionId: isSet(object.transactionId)
        ? globalThis.String(object.transactionId)
        : isSet(object.transaction_id)
        ? globalThis.String(object.transaction_id)
        : "",
    };
  },

  toJSON(message: RollbackRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RollbackRequest>, I>>(base?: I): RollbackRequest {
    return RollbackRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RollbackRequest>, I>>(object: I): RollbackRequest {
    const message = createBaseRollbackRequest();
    message.sessionId = object.sessionId ?? "";
    message.transactionId = object.transactionId ?? "";
    return message;
  },
};

function createBaseRollbackResponse(): RollbackResponse {
  return { status: undefined };
}

export const RollbackResponse: MessageFns<RollbackResponse> = {
  encode(message: RollbackResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      GqlStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RollbackResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollbackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = GqlStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RollbackResponse {
    return { status: isSet(object.status) ? GqlStatus.fromJSON(object.status) : undefined };
  },

  toJSON(message: RollbackResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = GqlStatus.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RollbackResponse>, I>>(base?: I): RollbackResponse {
    return RollbackResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RollbackResponse>, I>>(object: I): RollbackResponse {
    const message = createBaseRollbackResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? GqlStatus.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseListDatabasesRequest(): ListDatabasesRequest {
  return {};
}

export const ListDatabasesRequest: MessageFns<ListDatabasesRequest> = {
  encode(_: ListDatabasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDatabasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDatabasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListDatabasesRequest {
    return {};
  },

  toJSON(_: ListDatabasesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDatabasesRequest>, I>>(base?: I): ListDatabasesRequest {
    return ListDatabasesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDatabasesRequest>, I>>(_: I): ListDatabasesRequest {
    const message = createBaseListDatabasesRequest();
    return message;
  },
};

function createBaseDatabaseSummary(): DatabaseSummary {
  return { name: "", nodeCount: 0n, edgeCount: 0n, persistent: false, databaseType: "" };
}

export const DatabaseSummary: MessageFns<DatabaseSummary> = {
  encode(message: DatabaseSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.nodeCount !== 0n) {
      if (BigInt.asUintN(64, message.nodeCount) !== message.nodeCount) {
        throw new globalThis.Error("value provided for field message.nodeCount of type uint64 too large");
      }
      writer.uint32(16).uint64(message.nodeCount);
    }
    if (message.edgeCount !== 0n) {
      if (BigInt.asUintN(64, message.edgeCount) !== message.edgeCount) {
        throw new globalThis.Error("value provided for field message.edgeCount of type uint64 too large");
      }
      writer.uint32(24).uint64(message.edgeCount);
    }
    if (message.persistent !== false) {
      writer.uint32(32).bool(message.persistent);
    }
    if (message.databaseType !== "") {
      writer.uint32(42).string(message.databaseType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nodeCount = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.edgeCount = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.persistent = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.databaseType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseSummary {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nodeCount: isSet(object.nodeCount)
        ? BigInt(object.nodeCount)
        : isSet(object.node_count)
        ? BigInt(object.node_count)
        : 0n,
      edgeCount: isSet(object.edgeCount)
        ? BigInt(object.edgeCount)
        : isSet(object.edge_count)
        ? BigInt(object.edge_count)
        : 0n,
      persistent: isSet(object.persistent) ? globalThis.Boolean(object.persistent) : false,
      databaseType: isSet(object.databaseType)
        ? globalThis.String(object.databaseType)
        : isSet(object.database_type)
        ? globalThis.String(object.database_type)
        : "",
    };
  },

  toJSON(message: DatabaseSummary): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nodeCount !== 0n) {
      obj.nodeCount = message.nodeCount.toString();
    }
    if (message.edgeCount !== 0n) {
      obj.edgeCount = message.edgeCount.toString();
    }
    if (message.persistent !== false) {
      obj.persistent = message.persistent;
    }
    if (message.databaseType !== "") {
      obj.databaseType = message.databaseType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatabaseSummary>, I>>(base?: I): DatabaseSummary {
    return DatabaseSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatabaseSummary>, I>>(object: I): DatabaseSummary {
    const message = createBaseDatabaseSummary();
    message.name = object.name ?? "";
    message.nodeCount = object.nodeCount ?? 0n;
    message.edgeCount = object.edgeCount ?? 0n;
    message.persistent = object.persistent ?? false;
    message.databaseType = object.databaseType ?? "";
    return message;
  },
};

function createBaseListDatabasesResponse(): ListDatabasesResponse {
  return { databases: [] };
}

export const ListDatabasesResponse: MessageFns<ListDatabasesResponse> = {
  encode(message: ListDatabasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.databases) {
      DatabaseSummary.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDatabasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDatabasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.databases.push(DatabaseSummary.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDatabasesResponse {
    return {
      databases: globalThis.Array.isArray(object?.databases)
        ? object.databases.map((e: any) => DatabaseSummary.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListDatabasesResponse): unknown {
    const obj: any = {};
    if (message.databases?.length) {
      obj.databases = message.databases.map((e) => DatabaseSummary.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDatabasesResponse>, I>>(base?: I): ListDatabasesResponse {
    return ListDatabasesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDatabasesResponse>, I>>(object: I): ListDatabasesResponse {
    const message = createBaseListDatabasesResponse();
    message.databases = object.databases?.map((e) => DatabaseSummary.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateDatabaseRequest(): CreateDatabaseRequest {
  return { name: "", databaseType: "", storageMode: "", options: undefined };
}

export const CreateDatabaseRequest: MessageFns<CreateDatabaseRequest> = {
  encode(message: CreateDatabaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.databaseType !== "") {
      writer.uint32(18).string(message.databaseType);
    }
    if (message.storageMode !== "") {
      writer.uint32(26).string(message.storageMode);
    }
    if (message.options !== undefined) {
      DatabaseOptions.encode(message.options, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDatabaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDatabaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.databaseType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.storageMode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.options = DatabaseOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDatabaseRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      databaseType: isSet(object.databaseType)
        ? globalThis.String(object.databaseType)
        : isSet(object.database_type)
        ? globalThis.String(object.database_type)
        : "",
      storageMode: isSet(object.storageMode)
        ? globalThis.String(object.storageMode)
        : isSet(object.storage_mode)
        ? globalThis.String(object.storage_mode)
        : "",
      options: isSet(object.options) ? DatabaseOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: CreateDatabaseRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.databaseType !== "") {
      obj.databaseType = message.databaseType;
    }
    if (message.storageMode !== "") {
      obj.storageMode = message.storageMode;
    }
    if (message.options !== undefined) {
      obj.options = DatabaseOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateDatabaseRequest>, I>>(base?: I): CreateDatabaseRequest {
    return CreateDatabaseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateDatabaseRequest>, I>>(object: I): CreateDatabaseRequest {
    const message = createBaseCreateDatabaseRequest();
    message.name = object.name ?? "";
    message.databaseType = object.databaseType ?? "";
    message.storageMode = object.storageMode ?? "";
    message.options = (object.options !== undefined && object.options !== null)
      ? DatabaseOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseDatabaseOptions(): DatabaseOptions {
  return {
    memoryLimitBytes: undefined,
    backwardEdges: undefined,
    threads: undefined,
    walEnabled: undefined,
    walDurability: undefined,
  };
}

export const DatabaseOptions: MessageFns<DatabaseOptions> = {
  encode(message: DatabaseOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.memoryLimitBytes !== undefined) {
      if (BigInt.asUintN(64, message.memoryLimitBytes) !== message.memoryLimitBytes) {
        throw new globalThis.Error("value provided for field message.memoryLimitBytes of type uint64 too large");
      }
      writer.uint32(8).uint64(message.memoryLimitBytes);
    }
    if (message.backwardEdges !== undefined) {
      writer.uint32(16).bool(message.backwardEdges);
    }
    if (message.threads !== undefined) {
      writer.uint32(24).uint32(message.threads);
    }
    if (message.walEnabled !== undefined) {
      writer.uint32(32).bool(message.walEnabled);
    }
    if (message.walDurability !== undefined) {
      writer.uint32(42).string(message.walDurability);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.memoryLimitBytes = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.backwardEdges = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.threads = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.walEnabled = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.walDurability = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseOptions {
    return {
      memoryLimitBytes: isSet(object.memoryLimitBytes)
        ? BigInt(object.memoryLimitBytes)
        : isSet(object.memory_limit_bytes)
        ? BigInt(object.memory_limit_bytes)
        : undefined,
      backwardEdges: isSet(object.backwardEdges)
        ? globalThis.Boolean(object.backwardEdges)
        : isSet(object.backward_edges)
        ? globalThis.Boolean(object.backward_edges)
        : undefined,
      threads: isSet(object.threads) ? globalThis.Number(object.threads) : undefined,
      walEnabled: isSet(object.walEnabled)
        ? globalThis.Boolean(object.walEnabled)
        : isSet(object.wal_enabled)
        ? globalThis.Boolean(object.wal_enabled)
        : undefined,
      walDurability: isSet(object.walDurability)
        ? globalThis.String(object.walDurability)
        : isSet(object.wal_durability)
        ? globalThis.String(object.wal_durability)
        : undefined,
    };
  },

  toJSON(message: DatabaseOptions): unknown {
    const obj: any = {};
    if (message.memoryLimitBytes !== undefined) {
      obj.memoryLimitBytes = message.memoryLimitBytes.toString();
    }
    if (message.backwardEdges !== undefined) {
      obj.backwardEdges = message.backwardEdges;
    }
    if (message.threads !== undefined) {
      obj.threads = Math.round(message.threads);
    }
    if (message.walEnabled !== undefined) {
      obj.walEnabled = message.walEnabled;
    }
    if (message.walDurability !== undefined) {
      obj.walDurability = message.walDurability;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatabaseOptions>, I>>(base?: I): DatabaseOptions {
    return DatabaseOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatabaseOptions>, I>>(object: I): DatabaseOptions {
    const message = createBaseDatabaseOptions();
    message.memoryLimitBytes = object.memoryLimitBytes ?? undefined;
    message.backwardEdges = object.backwardEdges ?? undefined;
    message.threads = object.threads ?? undefined;
    message.walEnabled = object.walEnabled ?? undefined;
    message.walDurability = object.walDurability ?? undefined;
    return message;
  },
};

function createBaseCreateDatabaseResponse(): CreateDatabaseResponse {
  return { database: undefined };
}

export const CreateDatabaseResponse: MessageFns<CreateDatabaseResponse> = {
  encode(message: CreateDatabaseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.database !== undefined) {
      DatabaseSummary.encode(message.database, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDatabaseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDatabaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.database = DatabaseSummary.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDatabaseResponse {
    return { database: isSet(object.database) ? DatabaseSummary.fromJSON(object.database) : undefined };
  },

  toJSON(message: CreateDatabaseResponse): unknown {
    const obj: any = {};
    if (message.database !== undefined) {
      obj.database = DatabaseSummary.toJSON(message.database);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateDatabaseResponse>, I>>(base?: I): CreateDatabaseResponse {
    return CreateDatabaseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateDatabaseResponse>, I>>(object: I): CreateDatabaseResponse {
    const message = createBaseCreateDatabaseResponse();
    message.database = (object.database !== undefined && object.database !== null)
      ? DatabaseSummary.fromPartial(object.database)
      : undefined;
    return message;
  },
};

function createBaseDeleteDatabaseRequest(): DeleteDatabaseRequest {
  return { name: "" };
}

export const DeleteDatabaseRequest: MessageFns<DeleteDatabaseRequest> = {
  encode(message: DeleteDatabaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDatabaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDatabaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDatabaseRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteDatabaseRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteDatabaseRequest>, I>>(base?: I): DeleteDatabaseRequest {
    return DeleteDatabaseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteDatabaseRequest>, I>>(object: I): DeleteDatabaseRequest {
    const message = createBaseDeleteDatabaseRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteDatabaseResponse(): DeleteDatabaseResponse {
  return { deleted: "" };
}

export const DeleteDatabaseResponse: MessageFns<DeleteDatabaseResponse> = {
  encode(message: DeleteDatabaseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deleted !== "") {
      writer.uint32(10).string(message.deleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDatabaseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDatabaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deleted = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDatabaseResponse {
    return { deleted: isSet(object.deleted) ? globalThis.String(object.deleted) : "" };
  },

  toJSON(message: DeleteDatabaseResponse): unknown {
    const obj: any = {};
    if (message.deleted !== "") {
      obj.deleted = message.deleted;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteDatabaseResponse>, I>>(base?: I): DeleteDatabaseResponse {
    return DeleteDatabaseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteDatabaseResponse>, I>>(object: I): DeleteDatabaseResponse {
    const message = createBaseDeleteDatabaseResponse();
    message.deleted = object.deleted ?? "";
    return message;
  },
};

function createBaseGetDatabaseInfoRequest(): GetDatabaseInfoRequest {
  return { name: "" };
}

export const GetDatabaseInfoRequest: MessageFns<GetDatabaseInfoRequest> = {
  encode(message: GetDatabaseInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDatabaseInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDatabaseInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDatabaseInfoRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDatabaseInfoRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDatabaseInfoRequest>, I>>(base?: I): GetDatabaseInfoRequest {
    return GetDatabaseInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDatabaseInfoRequest>, I>>(object: I): GetDatabaseInfoRequest {
    const message = createBaseGetDatabaseInfoRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetDatabaseInfoResponse(): GetDatabaseInfoResponse {
  return {
    name: "",
    nodeCount: 0n,
    edgeCount: 0n,
    persistent: false,
    databaseType: "",
    storageMode: "",
    memoryLimitBytes: 0n,
    backwardEdges: false,
    threads: 0,
  };
}

export const GetDatabaseInfoResponse: MessageFns<GetDatabaseInfoResponse> = {
  encode(message: GetDatabaseInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.nodeCount !== 0n) {
      if (BigInt.asUintN(64, message.nodeCount) !== message.nodeCount) {
        throw new globalThis.Error("value provided for field message.nodeCount of type uint64 too large");
      }
      writer.uint32(16).uint64(message.nodeCount);
    }
    if (message.edgeCount !== 0n) {
      if (BigInt.asUintN(64, message.edgeCount) !== message.edgeCount) {
        throw new globalThis.Error("value provided for field message.edgeCount of type uint64 too large");
      }
      writer.uint32(24).uint64(message.edgeCount);
    }
    if (message.persistent !== false) {
      writer.uint32(32).bool(message.persistent);
    }
    if (message.databaseType !== "") {
      writer.uint32(42).string(message.databaseType);
    }
    if (message.storageMode !== "") {
      writer.uint32(50).string(message.storageMode);
    }
    if (message.memoryLimitBytes !== 0n) {
      if (BigInt.asUintN(64, message.memoryLimitBytes) !== message.memoryLimitBytes) {
        throw new globalThis.Error("value provided for field message.memoryLimitBytes of type uint64 too large");
      }
      writer.uint32(56).uint64(message.memoryLimitBytes);
    }
    if (message.backwardEdges !== false) {
      writer.uint32(64).bool(message.backwardEdges);
    }
    if (message.threads !== 0) {
      writer.uint32(72).uint32(message.threads);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDatabaseInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDatabaseInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nodeCount = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.edgeCount = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.persistent = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.databaseType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.storageMode = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.memoryLimitBytes = reader.uint64() as bigint;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.backwardEdges = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.threads = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDatabaseInfoResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nodeCount: isSet(object.nodeCount)
        ? BigInt(object.nodeCount)
        : isSet(object.node_count)
        ? BigInt(object.node_count)
        : 0n,
      edgeCount: isSet(object.edgeCount)
        ? BigInt(object.edgeCount)
        : isSet(object.edge_count)
        ? BigInt(object.edge_count)
        : 0n,
      persistent: isSet(object.persistent) ? globalThis.Boolean(object.persistent) : false,
      databaseType: isSet(object.databaseType)
        ? globalThis.String(object.databaseType)
        : isSet(object.database_type)
        ? globalThis.String(object.database_type)
        : "",
      storageMode: isSet(object.storageMode)
        ? globalThis.String(object.storageMode)
        : isSet(object.storage_mode)
        ? globalThis.String(object.storage_mode)
        : "",
      memoryLimitBytes: isSet(object.memoryLimitBytes)
        ? BigInt(object.memoryLimitBytes)
        : isSet(object.memory_limit_bytes)
        ? BigInt(object.memory_limit_bytes)
        : 0n,
      backwardEdges: isSet(object.backwardEdges)
        ? globalThis.Boolean(object.backwardEdges)
        : isSet(object.backward_edges)
        ? globalThis.Boolean(object.backward_edges)
        : false,
      threads: isSet(object.threads) ? globalThis.Number(object.threads) : 0,
    };
  },

  toJSON(message: GetDatabaseInfoResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nodeCount !== 0n) {
      obj.nodeCount = message.nodeCount.toString();
    }
    if (message.edgeCount !== 0n) {
      obj.edgeCount = message.edgeCount.toString();
    }
    if (message.persistent !== false) {
      obj.persistent = message.persistent;
    }
    if (message.databaseType !== "") {
      obj.databaseType = message.databaseType;
    }
    if (message.storageMode !== "") {
      obj.storageMode = message.storageMode;
    }
    if (message.memoryLimitBytes !== 0n) {
      obj.memoryLimitBytes = message.memoryLimitBytes.toString();
    }
    if (message.backwardEdges !== false) {
      obj.backwardEdges = message.backwardEdges;
    }
    if (message.threads !== 0) {
      obj.threads = Math.round(message.threads);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDatabaseInfoResponse>, I>>(base?: I): GetDatabaseInfoResponse {
    return GetDatabaseInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDatabaseInfoResponse>, I>>(object: I): GetDatabaseInfoResponse {
    const message = createBaseGetDatabaseInfoResponse();
    message.name = object.name ?? "";
    message.nodeCount = object.nodeCount ?? 0n;
    message.edgeCount = object.edgeCount ?? 0n;
    message.persistent = object.persistent ?? false;
    message.databaseType = object.databaseType ?? "";
    message.storageMode = object.storageMode ?? "";
    message.memoryLimitBytes = object.memoryLimitBytes ?? 0n;
    message.backwardEdges = object.backwardEdges ?? false;
    message.threads = object.threads ?? 0;
    return message;
  },
};

export type SessionServiceService = typeof SessionServiceService;
export const SessionServiceService = {
  /** Establish a session. Negotiates protocol version and authenticates. */
  handshake: {
    path: "/gql.SessionService/Handshake",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HandshakeRequest): Buffer => Buffer.from(HandshakeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): HandshakeRequest => HandshakeRequest.decode(value),
    responseSerialize: (value: HandshakeResponse): Buffer => Buffer.from(HandshakeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): HandshakeResponse => HandshakeResponse.decode(value),
  },
  /** Configure session state (schema, graph, timezone, parameters). */
  configure: {
    path: "/gql.SessionService/Configure",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ConfigureRequest): Buffer => Buffer.from(ConfigureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ConfigureRequest => ConfigureRequest.decode(value),
    responseSerialize: (value: ConfigureResponse): Buffer => Buffer.from(ConfigureResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ConfigureResponse => ConfigureResponse.decode(value),
  },
  /** Reset session state to defaults. */
  reset: {
    path: "/gql.SessionService/Reset",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResetRequest): Buffer => Buffer.from(ResetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResetRequest => ResetRequest.decode(value),
    responseSerialize: (value: ResetResponse): Buffer => Buffer.from(ResetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ResetResponse => ResetResponse.decode(value),
  },
  /** Terminate the session. Rolls back any active transaction. */
  close: {
    path: "/gql.SessionService/Close",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CloseRequest): Buffer => Buffer.from(CloseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CloseRequest => CloseRequest.decode(value),
    responseSerialize: (value: CloseResponse): Buffer => Buffer.from(CloseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CloseResponse => CloseResponse.decode(value),
  },
  /** Health check and keepalive. */
  ping: {
    path: "/gql.SessionService/Ping",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PingRequest): Buffer => Buffer.from(PingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PingRequest => PingRequest.decode(value),
    responseSerialize: (value: PongResponse): Buffer => Buffer.from(PongResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PongResponse => PongResponse.decode(value),
  },
} as const;

export interface SessionServiceServer extends UntypedServiceImplementation {
  /** Establish a session. Negotiates protocol version and authenticates. */
  handshake: handleUnaryCall<HandshakeRequest, HandshakeResponse>;
  /** Configure session state (schema, graph, timezone, parameters). */
  configure: handleUnaryCall<ConfigureRequest, ConfigureResponse>;
  /** Reset session state to defaults. */
  reset: handleUnaryCall<ResetRequest, ResetResponse>;
  /** Terminate the session. Rolls back any active transaction. */
  close: handleUnaryCall<CloseRequest, CloseResponse>;
  /** Health check and keepalive. */
  ping: handleUnaryCall<PingRequest, PongResponse>;
}

// @ts-expect-error SessionService.close() conflicts with grpc.Client.close()
export interface SessionServiceClient extends Client {
  /** Establish a session. Negotiates protocol version and authenticates. */
  handshake(
    request: HandshakeRequest,
    callback: (error: ServiceError | null, response: HandshakeResponse) => void,
  ): ClientUnaryCall;
  handshake(
    request: HandshakeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HandshakeResponse) => void,
  ): ClientUnaryCall;
  handshake(
    request: HandshakeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HandshakeResponse) => void,
  ): ClientUnaryCall;
  /** Configure session state (schema, graph, timezone, parameters). */
  configure(
    request: ConfigureRequest,
    callback: (error: ServiceError | null, response: ConfigureResponse) => void,
  ): ClientUnaryCall;
  configure(
    request: ConfigureRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ConfigureResponse) => void,
  ): ClientUnaryCall;
  configure(
    request: ConfigureRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ConfigureResponse) => void,
  ): ClientUnaryCall;
  /** Reset session state to defaults. */
  reset(
    request: ResetRequest,
    callback: (error: ServiceError | null, response: ResetResponse) => void,
  ): ClientUnaryCall;
  reset(
    request: ResetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResetResponse) => void,
  ): ClientUnaryCall;
  reset(
    request: ResetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResetResponse) => void,
  ): ClientUnaryCall;
  /** Terminate the session. Rolls back any active transaction. */
  close(
    request: CloseRequest,
    callback: (error: ServiceError | null, response: CloseResponse) => void,
  ): ClientUnaryCall;
  close(
    request: CloseRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CloseResponse) => void,
  ): ClientUnaryCall;
  close(
    request: CloseRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CloseResponse) => void,
  ): ClientUnaryCall;
  /** Health check and keepalive. */
  ping(request: PingRequest, callback: (error: ServiceError | null, response: PongResponse) => void): ClientUnaryCall;
  ping(
    request: PingRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PongResponse) => void,
  ): ClientUnaryCall;
  ping(
    request: PingRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PongResponse) => void,
  ): ClientUnaryCall;
}

export const SessionServiceClient = makeGenericClientConstructor(
  SessionServiceService,
  "gql.SessionService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): SessionServiceClient;
  service: typeof SessionServiceService;
  serviceName: string;
};

export type GqlServiceService = typeof GqlServiceService;
export const GqlServiceService = {
  /**
   * Execute any GQL statement. Returns a stream of response frames:
   *   1. ResultHeader  (column metadata or result type indicator)
   *   2. RowBatch*     (zero or more batches of rows)
   *   3. ResultSummary (completion status, row count, diagnostics)
   */
  execute: {
    path: "/gql.GqlService/Execute",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ExecuteRequest): Buffer => Buffer.from(ExecuteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExecuteRequest => ExecuteRequest.decode(value),
    responseSerialize: (value: ExecuteResponse): Buffer => Buffer.from(ExecuteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExecuteResponse => ExecuteResponse.decode(value),
  },
  /** Begin an explicit transaction. */
  beginTransaction: {
    path: "/gql.GqlService/BeginTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BeginRequest): Buffer => Buffer.from(BeginRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BeginRequest => BeginRequest.decode(value),
    responseSerialize: (value: BeginResponse): Buffer => Buffer.from(BeginResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BeginResponse => BeginResponse.decode(value),
  },
  /** Commit the active transaction. */
  commit: {
    path: "/gql.GqlService/Commit",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CommitRequest): Buffer => Buffer.from(CommitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CommitRequest => CommitRequest.decode(value),
    responseSerialize: (value: CommitResponse): Buffer => Buffer.from(CommitResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CommitResponse => CommitResponse.decode(value),
  },
  /** Roll back the active transaction. */
  rollback: {
    path: "/gql.GqlService/Rollback",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RollbackRequest): Buffer => Buffer.from(RollbackRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RollbackRequest => RollbackRequest.decode(value),
    responseSerialize: (value: RollbackResponse): Buffer => Buffer.from(RollbackResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RollbackResponse => RollbackResponse.decode(value),
  },
} as const;

export interface GqlServiceServer extends UntypedServiceImplementation {
  /**
   * Execute any GQL statement. Returns a stream of response frames:
   *   1. ResultHeader  (column metadata or result type indicator)
   *   2. RowBatch*     (zero or more batches of rows)
   *   3. ResultSummary (completion status, row count, diagnostics)
   */
  execute: handleServerStreamingCall<ExecuteRequest, ExecuteResponse>;
  /** Begin an explicit transaction. */
  beginTransaction: handleUnaryCall<BeginRequest, BeginResponse>;
  /** Commit the active transaction. */
  commit: handleUnaryCall<CommitRequest, CommitResponse>;
  /** Roll back the active transaction. */
  rollback: handleUnaryCall<RollbackRequest, RollbackResponse>;
}

export interface GqlServiceClient extends Client {
  /**
   * Execute any GQL statement. Returns a stream of response frames:
   *   1. ResultHeader  (column metadata or result type indicator)
   *   2. RowBatch*     (zero or more batches of rows)
   *   3. ResultSummary (completion status, row count, diagnostics)
   */
  execute(request: ExecuteRequest, options?: Partial<CallOptions>): ClientReadableStream<ExecuteResponse>;
  execute(
    request: ExecuteRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ExecuteResponse>;
  /** Begin an explicit transaction. */
  beginTransaction(
    request: BeginRequest,
    callback: (error: ServiceError | null, response: BeginResponse) => void,
  ): ClientUnaryCall;
  beginTransaction(
    request: BeginRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BeginResponse) => void,
  ): ClientUnaryCall;
  beginTransaction(
    request: BeginRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BeginResponse) => void,
  ): ClientUnaryCall;
  /** Commit the active transaction. */
  commit(
    request: CommitRequest,
    callback: (error: ServiceError | null, response: CommitResponse) => void,
  ): ClientUnaryCall;
  commit(
    request: CommitRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CommitResponse) => void,
  ): ClientUnaryCall;
  commit(
    request: CommitRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CommitResponse) => void,
  ): ClientUnaryCall;
  /** Roll back the active transaction. */
  rollback(
    request: RollbackRequest,
    callback: (error: ServiceError | null, response: RollbackResponse) => void,
  ): ClientUnaryCall;
  rollback(
    request: RollbackRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RollbackResponse) => void,
  ): ClientUnaryCall;
  rollback(
    request: RollbackRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RollbackResponse) => void,
  ): ClientUnaryCall;
}

export const GqlServiceClient = makeGenericClientConstructor(GqlServiceService, "gql.GqlService") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): GqlServiceClient;
  service: typeof GqlServiceService;
  serviceName: string;
};

export type DatabaseServiceService = typeof DatabaseServiceService;
export const DatabaseServiceService = {
  /** List all databases with summary info. */
  listDatabases: {
    path: "/gql.DatabaseService/ListDatabases",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListDatabasesRequest): Buffer => Buffer.from(ListDatabasesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListDatabasesRequest => ListDatabasesRequest.decode(value),
    responseSerialize: (value: ListDatabasesResponse): Buffer =>
      Buffer.from(ListDatabasesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListDatabasesResponse => ListDatabasesResponse.decode(value),
  },
  /** Create a new named database. */
  createDatabase: {
    path: "/gql.DatabaseService/CreateDatabase",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateDatabaseRequest): Buffer =>
      Buffer.from(CreateDatabaseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateDatabaseRequest => CreateDatabaseRequest.decode(value),
    responseSerialize: (value: CreateDatabaseResponse): Buffer =>
      Buffer.from(CreateDatabaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateDatabaseResponse => CreateDatabaseResponse.decode(value),
  },
  /** Delete a database by name. Cannot delete "default". */
  deleteDatabase: {
    path: "/gql.DatabaseService/DeleteDatabase",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteDatabaseRequest): Buffer =>
      Buffer.from(DeleteDatabaseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteDatabaseRequest => DeleteDatabaseRequest.decode(value),
    responseSerialize: (value: DeleteDatabaseResponse): Buffer =>
      Buffer.from(DeleteDatabaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteDatabaseResponse => DeleteDatabaseResponse.decode(value),
  },
  /** Get database info (node/edge counts, metadata). */
  getDatabaseInfo: {
    path: "/gql.DatabaseService/GetDatabaseInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDatabaseInfoRequest): Buffer =>
      Buffer.from(GetDatabaseInfoRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetDatabaseInfoRequest => GetDatabaseInfoRequest.decode(value),
    responseSerialize: (value: GetDatabaseInfoResponse): Buffer =>
      Buffer.from(GetDatabaseInfoResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetDatabaseInfoResponse => GetDatabaseInfoResponse.decode(value),
  },
} as const;

export interface DatabaseServiceServer extends UntypedServiceImplementation {
  /** List all databases with summary info. */
  listDatabases: handleUnaryCall<ListDatabasesRequest, ListDatabasesResponse>;
  /** Create a new named database. */
  createDatabase: handleUnaryCall<CreateDatabaseRequest, CreateDatabaseResponse>;
  /** Delete a database by name. Cannot delete "default". */
  deleteDatabase: handleUnaryCall<DeleteDatabaseRequest, DeleteDatabaseResponse>;
  /** Get database info (node/edge counts, metadata). */
  getDatabaseInfo: handleUnaryCall<GetDatabaseInfoRequest, GetDatabaseInfoResponse>;
}

export interface DatabaseServiceClient extends Client {
  /** List all databases with summary info. */
  listDatabases(
    request: ListDatabasesRequest,
    callback: (error: ServiceError | null, response: ListDatabasesResponse) => void,
  ): ClientUnaryCall;
  listDatabases(
    request: ListDatabasesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListDatabasesResponse) => void,
  ): ClientUnaryCall;
  listDatabases(
    request: ListDatabasesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListDatabasesResponse) => void,
  ): ClientUnaryCall;
  /** Create a new named database. */
  createDatabase(
    request: CreateDatabaseRequest,
    callback: (error: ServiceError | null, response: CreateDatabaseResponse) => void,
  ): ClientUnaryCall;
  createDatabase(
    request: CreateDatabaseRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateDatabaseResponse) => void,
  ): ClientUnaryCall;
  createDatabase(
    request: CreateDatabaseRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateDatabaseResponse) => void,
  ): ClientUnaryCall;
  /** Delete a database by name. Cannot delete "default". */
  deleteDatabase(
    request: DeleteDatabaseRequest,
    callback: (error: ServiceError | null, response: DeleteDatabaseResponse) => void,
  ): ClientUnaryCall;
  deleteDatabase(
    request: DeleteDatabaseRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteDatabaseResponse) => void,
  ): ClientUnaryCall;
  deleteDatabase(
    request: DeleteDatabaseRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteDatabaseResponse) => void,
  ): ClientUnaryCall;
  /** Get database info (node/edge counts, metadata). */
  getDatabaseInfo(
    request: GetDatabaseInfoRequest,
    callback: (error: ServiceError | null, response: GetDatabaseInfoResponse) => void,
  ): ClientUnaryCall;
  getDatabaseInfo(
    request: GetDatabaseInfoRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetDatabaseInfoResponse) => void,
  ): ClientUnaryCall;
  getDatabaseInfo(
    request: GetDatabaseInfoRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetDatabaseInfoResponse) => void,
  ): ClientUnaryCall;
}

export const DatabaseServiceClient = makeGenericClientConstructor(
  DatabaseServiceService,
  "gql.DatabaseService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): DatabaseServiceClient;
  service: typeof DatabaseServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
